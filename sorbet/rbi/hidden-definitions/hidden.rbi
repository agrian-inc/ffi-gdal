# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def global_path_appends_ruby_scope?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def backport_ext_builder_monitor(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BasenameSetting
end

class Byebug::BreakCommand
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
end

class Byebug::CatchCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(); end

  def help(*args, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def processor(); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandNotFound
end

class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, &block); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, &block); end

  def puts(*args, &block); end

  def repl(); end
end

class Byebug::CommandProcessor
  extend ::Forwardable
end

class Byebug::ConditionCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::ControlProcessor
end

class Byebug::DebugCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
  def self.inherited(); end
end

class Byebug::DeleteCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  include ::Byebug::Subcommands
end

class Byebug::DisableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  include ::Byebug::Subcommands
end

class Byebug::EnableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  include ::Byebug::Helpers::FileHelper
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::Frame
end

class Byebug::FrameCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::FullpathSetting
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::BinHelper
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::EvalHelper
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FileHelper
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::FrameHelper
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::ParseHelper
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::PathHelper
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::ReflectionHelper
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::StringHelper
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ThreadHelper
end

module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::ToggleHelper
end

module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

module Byebug::Helpers::VarHelper
end

module Byebug::Helpers
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::History
end

class Byebug::HistoryCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
end

class Byebug::InfoCommand
  include ::Byebug::Subcommands
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  include ::Byebug::Helpers::FileHelper
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::Interface
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::LinetraceSetting
end

class Byebug::ListCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def amend_final(*args, &block); end

  def execute(); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end

  def without_readline_completion(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
end

class Byebug::MethodCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemProcessor
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::PostMortemSetting
end

module Byebug::Printers
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::Printers::Plain
end

module Byebug::Printers
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Remote
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Client
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::Remote::Server
end

module Byebug::Remote
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RemoteInterface
end

class Byebug::RestartCommand
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptInterface
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::ScriptProcessor
end

class Byebug::SetCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  include ::Byebug::Helpers::ParseHelper
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::SourceFileFormatter
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StackOnErrorSetting
end

class Byebug::StepCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands::ClassMethods
end

module Byebug::Subcommands
  extend ::Forwardable
  def self.included(command); end
end

class Byebug::ThreadCommand
  include ::Byebug::Subcommands
end

class Byebug::ThreadCommand::CurrentCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  include ::Byebug::Subcommands
end

class Byebug::VarCommand::AllCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  include ::Byebug::Helpers::FrameHelper
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::WidthSetting
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.attach(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.spawn(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(_); end

end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

class Docile::ChainingFallbackContextProxy
end

class Docile::ChainingFallbackContextProxy
end

module Docile::Execution
end

module Docile::Execution
  def self.exec_in_proxy_context(dsl, proxy_type, *args, &block); end
end

class Docile::FallbackContextProxy
  def initialize(receiver, fallback); end

  def method_missing(method, *args, &block); end
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class Docile::FallbackContextProxy
end

module Docile
  extend ::Docile::Execution
  def self.dsl_eval(dsl, *args, &block); end

  def self.dsl_eval_immutable(dsl, *args, &block); end

  def self.dsl_eval_with_block_return(dsl, *args, &block); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def chain(*_); end

  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Examples::RemoveSmallPolygons
end

class Exception
  def __bb_context(); end
end

module Exception2MessageMapper
  def bind(cl); end

end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FFI::AbstractMemory
  def [](_); end

  def __copy_from__(_, _1); end

  def clear(); end

  def get(_, _1); end

  def get_array_of_char(_, _1); end

  def get_array_of_double(_, _1); end

  def get_array_of_float(_, _1); end

  def get_array_of_float32(_, _1); end

  def get_array_of_float64(_, _1); end

  def get_array_of_int(_, _1); end

  def get_array_of_int16(_, _1); end

  def get_array_of_int32(_, _1); end

  def get_array_of_int64(_, _1); end

  def get_array_of_int8(_, _1); end

  def get_array_of_long(_, _1); end

  def get_array_of_long_long(_, _1); end

  def get_array_of_pointer(_, _1); end

  def get_array_of_short(_, _1); end

  def get_array_of_string(*_); end

  def get_array_of_uchar(_, _1); end

  def get_array_of_uint(_, _1); end

  def get_array_of_uint16(_, _1); end

  def get_array_of_uint32(_, _1); end

  def get_array_of_uint64(_, _1); end

  def get_array_of_uint8(_, _1); end

  def get_array_of_ulong(_, _1); end

  def get_array_of_ulong_long(_, _1); end

  def get_array_of_ushort(_, _1); end

  def get_bytes(_, _1); end

  def get_char(_); end

  def get_double(_); end

  def get_float(_); end

  def get_float32(_); end

  def get_float64(_); end

  def get_int(_); end

  def get_int16(_); end

  def get_int32(_); end

  def get_int64(_); end

  def get_int8(_); end

  def get_long(_); end

  def get_long_long(_); end

  def get_pointer(_); end

  def get_short(_); end

  def get_string(*_); end

  def get_uchar(_); end

  def get_uint(_); end

  def get_uint16(_); end

  def get_uint32(_); end

  def get_uint64(_); end

  def get_uint8(_); end

  def get_ulong(_); end

  def get_ulong_long(_); end

  def get_ushort(_); end

  def put(_, _1, _2); end

  def put_array_of_char(_, _1); end

  def put_array_of_double(_, _1); end

  def put_array_of_float(_, _1); end

  def put_array_of_float32(_, _1); end

  def put_array_of_float64(_, _1); end

  def put_array_of_int(_, _1); end

  def put_array_of_int16(_, _1); end

  def put_array_of_int32(_, _1); end

  def put_array_of_int64(_, _1); end

  def put_array_of_int8(_, _1); end

  def put_array_of_long(_, _1); end

  def put_array_of_long_long(_, _1); end

  def put_array_of_pointer(_, _1); end

  def put_array_of_short(_, _1); end

  def put_array_of_uchar(_, _1); end

  def put_array_of_uint(_, _1); end

  def put_array_of_uint16(_, _1); end

  def put_array_of_uint32(_, _1); end

  def put_array_of_uint64(_, _1); end

  def put_array_of_uint8(_, _1); end

  def put_array_of_ulong(_, _1); end

  def put_array_of_ulong_long(_, _1); end

  def put_array_of_ushort(_, _1); end

  def put_bytes(*_); end

  def put_char(_, _1); end

  def put_double(_, _1); end

  def put_float(_, _1); end

  def put_float32(_, _1); end

  def put_float64(_, _1); end

  def put_int(_, _1); end

  def put_int16(_, _1); end

  def put_int32(_, _1); end

  def put_int64(_, _1); end

  def put_int8(_, _1); end

  def put_long(_, _1); end

  def put_long_long(_, _1); end

  def put_pointer(_, _1); end

  def put_short(_, _1); end

  def put_string(_, _1); end

  def put_uchar(_, _1); end

  def put_uint(_, _1); end

  def put_uint16(_, _1); end

  def put_uint32(_, _1); end

  def put_uint64(_, _1); end

  def put_uint8(_, _1); end

  def put_ulong(_, _1); end

  def put_ulong_long(_, _1); end

  def put_ushort(_, _1); end

  def read_array_of_char(_); end

  def read_array_of_double(_); end

  def read_array_of_float(_); end

  def read_array_of_int(_); end

  def read_array_of_int16(_); end

  def read_array_of_int32(_); end

  def read_array_of_int64(_); end

  def read_array_of_int8(_); end

  def read_array_of_long(_); end

  def read_array_of_long_long(_); end

  def read_array_of_pointer(_); end

  def read_array_of_short(_); end

  def read_array_of_uchar(_); end

  def read_array_of_uint(_); end

  def read_array_of_uint16(_); end

  def read_array_of_uint32(_); end

  def read_array_of_uint64(_); end

  def read_array_of_uint8(_); end

  def read_array_of_ulong(_); end

  def read_array_of_ulong_long(_); end

  def read_array_of_ushort(_); end

  def read_bytes(_); end

  def read_char(); end

  def read_double(); end

  def read_float(); end

  def read_int(); end

  def read_int16(); end

  def read_int32(); end

  def read_int64(); end

  def read_int8(); end

  def read_long(); end

  def read_long_long(); end

  def read_pointer(); end

  def read_short(); end

  def read_uchar(); end

  def read_uint(); end

  def read_uint16(); end

  def read_uint32(); end

  def read_uint64(); end

  def read_uint8(); end

  def read_ulong(); end

  def read_ulong_long(); end

  def read_ushort(); end

  def size(); end

  def total(); end

  def type_size(); end

  def write_array_of_char(_); end

  def write_array_of_double(_); end

  def write_array_of_float(_); end

  def write_array_of_int(_); end

  def write_array_of_int16(_); end

  def write_array_of_int32(_); end

  def write_array_of_int64(_); end

  def write_array_of_int8(_); end

  def write_array_of_long(_); end

  def write_array_of_long_long(_); end

  def write_array_of_pointer(_); end

  def write_array_of_short(_); end

  def write_array_of_uchar(_); end

  def write_array_of_uint(_); end

  def write_array_of_uint16(_); end

  def write_array_of_uint32(_); end

  def write_array_of_uint64(_); end

  def write_array_of_uint8(_); end

  def write_array_of_ulong(_); end

  def write_array_of_ulong_long(_); end

  def write_array_of_ushort(_); end

  def write_bytes(*_); end

  def write_char(_); end

  def write_double(_); end

  def write_float(_); end

  def write_int(_); end

  def write_int16(_); end

  def write_int32(_); end

  def write_int64(_); end

  def write_int8(_); end

  def write_long(_); end

  def write_long_long(_); end

  def write_pointer(_); end

  def write_short(_); end

  def write_uchar(_); end

  def write_uint(_); end

  def write_uint16(_); end

  def write_uint32(_); end

  def write_uint64(_); end

  def write_uint8(_); end

  def write_ulong(_); end

  def write_ulong_long(_); end

  def write_ushort(_); end
end

class FFI::AbstractMemory
end

class FFI::ArrayType
  def elem_type(); end

  def initialize(_, _1); end

  def length(); end
end

class FFI::ArrayType
end

class FFI::AutoPointer
  def autorelease=(autorelease); end

  def initialize(ptr, proc=T.unsafe(nil), &block); end
end

class FFI::AutoPointer::CallableReleaser
  def release(ptr); end
end

class FFI::AutoPointer::CallableReleaser
end

class FFI::AutoPointer::DefaultReleaser
  def release(ptr); end
end

class FFI::AutoPointer::DefaultReleaser
end

class FFI::AutoPointer::Releaser
  def autorelease(); end

  def autorelease=(autorelease); end

  def call(*args); end

  def free(); end

  def initialize(ptr, proc); end
end

class FFI::AutoPointer::Releaser
end

class FFI::AutoPointer
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end

  def self.native_type(); end
end

class FFI::Bitmask
  def [](*query); end

  def to_native(query, ctx); end
end

class FFI::Bitmask
end

class FFI::Buffer
  def +(_); end

  def initialize(*_); end

  def length(); end

  def order(*_); end

  def slice(_, _1); end
end

class FFI::Buffer
  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end
end

module FFI::CPL::Conv
  def CPLAtof(*_); end

  def CPLAtofDelim(*_); end

  def CPLAtofM(*_); end

  def CPLCalloc(*_); end

  def CPLCheckForFile(*_); end

  def CPLCleanTrailingSlash(*_); end

  def CPLCleanupSetlocaleMutex(*_); end

  def CPLCleanupSharedFileMutex(*_); end

  def CPLCloseFileInZip(*_); end

  def CPLCloseShared(*_); end

  def CPLCloseZip(*_); end

  def CPLCopyFile(*_); end

  def CPLCorrespondingPaths(*_); end

  def CPLCreateFileInZip(*_); end

  def CPLCreateZip(*_); end

  def CPLDMSToDec(*_); end

  def CPLDecToDMS(*_); end

  def CPLDecToPackedDMS(*_); end

  def CPLDefaultFindFile(*_); end

  def CPLDumpSharedList(*_); end

  def CPLExtractRelativePath(*_); end

  def CPLFGets(*_); end

  def CPLFindFile(*_); end

  def CPLFinderClean(*_); end

  def CPLFormCIFilename(*_); end

  def CPLFormFilename(*_); end

  def CPLFreeConfig(*_); end

  def CPLGenerateTempFilename(*_); end

  def CPLGetBasename(*_); end

  def CPLGetConfigOption(*_); end

  def CPLGetCurrentDir(*_); end

  def CPLGetDirname(*_); end

  def CPLGetExecPath(*_); end

  def CPLGetExtension(*_); end

  def CPLGetFilename(*_); end

  def CPLGetPath(*_); end

  def CPLGetSharedList(*_); end

  def CPLGetSymbol(*_); end

  def CPLIsFilenameRelative(*_); end

  def CPLMalloc(*_); end

  def CPLMoveFile(*_); end

  def CPLOpenShared(*_); end

  def CPLPackedDMSToDec(*_); end

  def CPLPopFileFinder(*_); end

  def CPLPopFinderLocation(*_); end

  def CPLPrintDouble(*_); end

  def CPLPrintInt32(*_); end

  def CPLPrintPointer(*_); end

  def CPLPrintString(*_); end

  def CPLPrintStringFill(*_); end

  def CPLPrintTime(*_); end

  def CPLPrintUIntBig(*_); end

  def CPLProjectRelativeFilename(*_); end

  def CPLPushFileFinder(*_); end

  def CPLPushFinderLocation(*_); end

  def CPLReadLine(*_); end

  def CPLReadLine2L(*_); end

  def CPLReadLineL(*_); end

  def CPLRealloc(*_); end

  def CPLResetExtension(*_); end

  def CPLScanDouble(*_); end

  def CPLScanLong(*_); end

  def CPLScanPointer(*_); end

  def CPLScanString(*_); end

  def CPLScanUIntBig(*_); end

  def CPLScanULong(*_); end

  def CPLSetConfigOption(*_); end

  def CPLSetThreadLocalConfigOption(*_); end

  def CPLStat(*_); end

  def CPLStrdup(*_); end

  def CPLStringToComplex(*_); end

  def CPLStrlwr(*_); end

  def CPLStrtod(*_); end

  def CPLStrtodDelim(*_); end

  def CPLStrtof(*_); end

  def CPLStrtofDelim(*_); end

  def CPLUnlinkTree(*_); end

  def CPLValidateXML(*_); end

  def CPLVerifyConfiguration(*_); end

  def CPLWriteFileInZip(*_); end

  def CPLZLibDeflate(*_); end

  def CPLZLibInflate(*_); end

  def CPLsetlocale(*_); end
end

module FFI::CPL::Conv
  def self.CPLAtof(*_); end

  def self.CPLAtofDelim(*_); end

  def self.CPLAtofM(*_); end

  def self.CPLCalloc(*_); end

  def self.CPLCheckForFile(*_); end

  def self.CPLCleanTrailingSlash(*_); end

  def self.CPLCleanupSetlocaleMutex(*_); end

  def self.CPLCleanupSharedFileMutex(*_); end

  def self.CPLCloseFileInZip(*_); end

  def self.CPLCloseShared(*_); end

  def self.CPLCloseZip(*_); end

  def self.CPLCopyFile(*_); end

  def self.CPLCorrespondingPaths(*_); end

  def self.CPLCreateFileInZip(*_); end

  def self.CPLCreateZip(*_); end

  def self.CPLDMSToDec(*_); end

  def self.CPLDecToDMS(*_); end

  def self.CPLDecToPackedDMS(*_); end

  def self.CPLDefaultFindFile(*_); end

  def self.CPLDumpSharedList(*_); end

  def self.CPLExtractRelativePath(*_); end

  def self.CPLFGets(*_); end

  def self.CPLFindFile(*_); end

  def self.CPLFinderClean(*_); end

  def self.CPLFormCIFilename(*_); end

  def self.CPLFormFilename(*_); end

  def self.CPLFreeConfig(*_); end

  def self.CPLGenerateTempFilename(*_); end

  def self.CPLGetBasename(*_); end

  def self.CPLGetConfigOption(*_); end

  def self.CPLGetCurrentDir(*_); end

  def self.CPLGetDirname(*_); end

  def self.CPLGetExecPath(*_); end

  def self.CPLGetExtension(*_); end

  def self.CPLGetFilename(*_); end

  def self.CPLGetPath(*_); end

  def self.CPLGetSharedList(*_); end

  def self.CPLGetSymbol(*_); end

  def self.CPLIsFilenameRelative(*_); end

  def self.CPLMalloc(*_); end

  def self.CPLMoveFile(*_); end

  def self.CPLOpenShared(*_); end

  def self.CPLPackedDMSToDec(*_); end

  def self.CPLPopFileFinder(*_); end

  def self.CPLPopFinderLocation(*_); end

  def self.CPLPrintDouble(*_); end

  def self.CPLPrintInt32(*_); end

  def self.CPLPrintPointer(*_); end

  def self.CPLPrintString(*_); end

  def self.CPLPrintStringFill(*_); end

  def self.CPLPrintTime(*_); end

  def self.CPLPrintUIntBig(*_); end

  def self.CPLProjectRelativeFilename(*_); end

  def self.CPLPushFileFinder(*_); end

  def self.CPLPushFinderLocation(*_); end

  def self.CPLReadLine(*_); end

  def self.CPLReadLine2L(*_); end

  def self.CPLReadLineL(*_); end

  def self.CPLRealloc(*_); end

  def self.CPLResetExtension(*_); end

  def self.CPLScanDouble(*_); end

  def self.CPLScanLong(*_); end

  def self.CPLScanPointer(*_); end

  def self.CPLScanString(*_); end

  def self.CPLScanUIntBig(*_); end

  def self.CPLScanULong(*_); end

  def self.CPLSetConfigOption(*_); end

  def self.CPLSetThreadLocalConfigOption(*_); end

  def self.CPLStat(*_); end

  def self.CPLStrdup(*_); end

  def self.CPLStringToComplex(*_); end

  def self.CPLStrlwr(*_); end

  def self.CPLStrtod(*_); end

  def self.CPLStrtodDelim(*_); end

  def self.CPLStrtof(*_); end

  def self.CPLStrtofDelim(*_); end

  def self.CPLUnlinkTree(*_); end

  def self.CPLValidateXML(*_); end

  def self.CPLVerifyConfiguration(*_); end

  def self.CPLWriteFileInZip(*_); end

  def self.CPLZLibDeflate(*_); end

  def self.CPLZLibInflate(*_); end

  def self.CPLsetlocale(*_); end
end

module FFI::CPL::Error
  def CPLCleanupErrorMutex(*_); end

  def CPLDebug(*_); end

  def CPLDefaultErrorHandler(*_); end

  def CPLEmergencyError(*_); end

  def CPLError(*_); end

  def CPLErrorReset(*_); end

  def CPLErrorV(*_); end

  def CPLGetErrorHandlerUserData(*_); end

  def CPLGetLastErrorMsg(*_); end

  def CPLGetLastErrorNo(*_); end

  def CPLGetLastErrorType(*_); end

  def CPLLoggingErrorHandler(*_); end

  def CPLPopErrorHandler(*_); end

  def CPLPushErrorHandler(*_); end

  def CPLPushErrorHandlerEx(*_); end

  def CPLQuietErrorHandler(*_); end

  def CPLSetErrorHandler(*_); end

  def CPLSetErrorHandlerEx(*_); end

  def CPLTurnFailureIntoWarning(*_); end

  def _CPLAssert(*_); end
end

module FFI::CPL::Error
  def self.CPLCleanupErrorMutex(*_); end

  def self.CPLDebug(*_); end

  def self.CPLDefaultErrorHandler(*_); end

  def self.CPLEmergencyError(*_); end

  def self.CPLError(*_); end

  def self.CPLErrorReset(*_); end

  def self.CPLErrorV(*_); end

  def self.CPLGetErrorHandlerUserData(*_); end

  def self.CPLGetLastErrorMsg(*_); end

  def self.CPLGetLastErrorNo(*_); end

  def self.CPLGetLastErrorType(*_); end

  def self.CPLLoggingErrorHandler(*_); end

  def self.CPLPopErrorHandler(*_); end

  def self.CPLPushErrorHandler(*_); end

  def self.CPLPushErrorHandlerEx(*_); end

  def self.CPLQuietErrorHandler(*_); end

  def self.CPLSetErrorHandler(*_); end

  def self.CPLSetErrorHandlerEx(*_); end

  def self.CPLTurnFailureIntoWarning(*_); end

  def self._CPLAssert(*_); end
end

module FFI::CPL::HTTP
  def CPLHTTPCleanup(*_); end

  def CPLHTTPDestroyResult(*_); end

  def CPLHTTPEnabled(*_); end

  def CPLHTTPFetch(*_); end

  def CPLHTTPParseMultipartMime(*_); end

  def GOA2GetAccessToken(*_); end

  def GOA2GetAuthorizationURL(*_); end

  def GOA2GetRefreshToken(*_); end
end

module FFI::CPL::HTTP
  def self.CPLHTTPCleanup(*_); end

  def self.CPLHTTPDestroyResult(*_); end

  def self.CPLHTTPEnabled(*_); end

  def self.CPLHTTPFetch(*_); end

  def self.CPLHTTPParseMultipartMime(*_); end

  def self.GOA2GetAccessToken(*_); end

  def self.GOA2GetAuthorizationURL(*_); end

  def self.GOA2GetRefreshToken(*_); end
end

class FFI::CPL::HTTPResult
end

module FFI::CPL::HashSet
  def CPLHashSetDestroy(*_); end

  def CPLHashSetEqualPointer(*_); end

  def CPLHashSetEqualStr(*_); end

  def CPLHashSetForeach(*_); end

  def CPLHashSetHashPointer(*_); end

  def CPLHashSetHashStr(*_); end

  def CPLHashSetInsert(*_); end

  def CPLHashSetLookup(*_); end

  def CPLHashSetNew(*_); end

  def CPLHashSetRemove(*_); end

  def CPLHashSetSize(*_); end
end

module FFI::CPL::HashSet
  def self.CPLHashSetDestroy(*_); end

  def self.CPLHashSetEqualPointer(*_); end

  def self.CPLHashSetEqualStr(*_); end

  def self.CPLHashSetForeach(*_); end

  def self.CPLHashSetHashPointer(*_); end

  def self.CPLHashSetHashStr(*_); end

  def self.CPLHashSetInsert(*_); end

  def self.CPLHashSetLookup(*_); end

  def self.CPLHashSetNew(*_); end

  def self.CPLHashSetRemove(*_); end

  def self.CPLHashSetSize(*_); end
end

class FFI::CPL::List
end

module FFI::CPL::List::ListFunctions::ClassMethods
  def CPLListAppend(*_); end

  def CPLListCount(*_); end

  def CPLListDestroy(*_); end

  def CPLListGet(*_); end

  def CPLListGetData(*_); end

  def CPLListGetLast(*_); end

  def CPLListGetNext(*_); end

  def CPLListInsert(*_); end

  def CPLListRemove(*_); end
end

module FFI::CPL::List::ListFunctions::ClassMethods
  def self.CPLListAppend(*_); end

  def self.CPLListCount(*_); end

  def self.CPLListDestroy(*_); end

  def self.CPLListGet(*_); end

  def self.CPLListGetData(*_); end

  def self.CPLListGetLast(*_); end

  def self.CPLListGetNext(*_); end

  def self.CPLListInsert(*_); end

  def self.CPLListRemove(*_); end
end

class FFI::CPL::List
  extend ::FFI::CPL::List::ListFunctions::ClassMethods
end

class FFI::CPL::MIMEPart
end

module FFI::CPL::MiniXML
  def CPLAddXMLChild(*_); end

  def CPLAddXMLSibling(*_); end

  def CPLCleanXMLElementName(*_); end

  def CPLCloneXMLTree(*_); end

  def CPLCreateXMLElementAndValue(*_); end

  def CPLCreateXMLNode(*_); end

  def CPLDestroyXMLNode(*_); end

  def CPLGetXMLNode(*_); end

  def CPLGetXMLValue(*_); end

  def CPLParseXMLFile(*_); end

  def CPLParseXMLString(*_); end

  def CPLRemoveXMLChild(*_); end

  def CPLSearchXMLNode(*_); end

  def CPLSerializeXMLTree(*_); end

  def CPLSerializeXMLTreeToFile(*_); end

  def CPLSetXMLValue(*_); end

  def CPLStripXMLNamespace(*_); end
end

module FFI::CPL::MiniXML
  def self.CPLAddXMLChild(*_); end

  def self.CPLAddXMLSibling(*_); end

  def self.CPLCleanXMLElementName(*_); end

  def self.CPLCloneXMLTree(*_); end

  def self.CPLCreateXMLElementAndValue(*_); end

  def self.CPLCreateXMLNode(*_); end

  def self.CPLDestroyXMLNode(*_); end

  def self.CPLGetXMLNode(*_); end

  def self.CPLGetXMLValue(*_); end

  def self.CPLParseXMLFile(*_); end

  def self.CPLParseXMLString(*_); end

  def self.CPLRemoveXMLChild(*_); end

  def self.CPLSearchXMLNode(*_); end

  def self.CPLSerializeXMLTree(*_); end

  def self.CPLSerializeXMLTreeToFile(*_); end

  def self.CPLSetXMLValue(*_); end

  def self.CPLStripXMLNamespace(*_); end
end

module FFI::CPL::Progress
  def GDALCreateScaledProgress(*_); end

  def GDALDestroyScaledProgress(*_); end

  def GDALScaledProgress(*_); end

  def GDALTermProgress(*_); end
end

module FFI::CPL::Progress
  def self.GDALCreateScaledProgress(*_); end

  def self.GDALDestroyScaledProgress(*_); end

  def self.GDALScaledProgress(*_); end

  def self.GDALTermProgress(*_); end
end

module FFI::CPL::QuadTree
  def CPLQuadTreeCreate(*_); end

  def CPLQuadTreeDestroy(*_); end

  def CPLQuadTreeDump(*_); end

  def CPLQuadTreeForeach(*_); end

  def CPLQuadTreeGetAdvisedMaxDepth(*_); end

  def CPLQuadTreeGetStats(*_); end

  def CPLQuadTreeInsert(*_); end

  def CPLQuadTreeInsertWithBounds(*_); end

  def CPLQuadTreeSearch(*_); end

  def CPLQuadTreeSetBucketCapacity(*_); end

  def CPLQuadTreeSetMaxDepth(*_); end
end

module FFI::CPL::QuadTree
  def self.CPLQuadTreeCreate(*_); end

  def self.CPLQuadTreeDestroy(*_); end

  def self.CPLQuadTreeDump(*_); end

  def self.CPLQuadTreeForeach(*_); end

  def self.CPLQuadTreeGetAdvisedMaxDepth(*_); end

  def self.CPLQuadTreeGetStats(*_); end

  def self.CPLQuadTreeInsert(*_); end

  def self.CPLQuadTreeInsertWithBounds(*_); end

  def self.CPLQuadTreeSearch(*_); end

  def self.CPLQuadTreeSetBucketCapacity(*_); end

  def self.CPLQuadTreeSetMaxDepth(*_); end
end

class FFI::CPL::RectObj
end

module FFI::CPL::String
  def CPLBase64DecodeInPlace(*_); end

  def CPLBase64Encode(*_); end

  def CPLBinaryToHex(*_); end

  def CPLClearRecodeWarningFlags(*_); end

  def CPLEncodingCharSize(*_); end

  def CPLEscapeString(*_); end

  def CPLForceToASCII(*_); end

  def CPLGetValueType(*_); end

  def CPLHexToBinary(*_); end

  def CPLIsUTF8(*_); end

  def CPLParseNameValue(*_); end

  def CPLRecode(*_); end

  def CPLRecodeFromWChar(*_); end

  def CPLRecodeToWChar(*_); end

  def CPLSPrintf(*args); end

  def CPLStrlcat(*_); end

  def CPLStrlcpy(*_); end

  def CPLStrlenUTF8(*_); end

  def CPLStrnlen(*_); end

  def CPLUnescapeString(*_); end

  def CPLVASPrintf(*args); end

  def CSLAddNameValue(*_); end

  def CSLAddString(*_); end

  def CSLAppendPrintf(*args); end

  def CSLCount(*_); end

  def CSLDestroy(*_); end

  def CSLDuplicate(*_); end

  def CSLFetchBoolean(*_); end

  def CSLFetchNameValue(*_); end

  def CSLFetchNameValueDef(*_); end

  def CSLFetchNameValueMultiple(*_); end

  def CSLFindName(*_); end

  def CSLFindString(*_); end

  def CSLGetField(*_); end

  def CSLInsertString(*_); end

  def CSLInsertStrings(*_); end

  def CSLLoad(*_); end

  def CSLLoad2(*_); end

  def CSLMerge(*_); end

  def CSLPartialFindString(*_); end

  def CSLPrint(*_); end

  def CSLRemoveStrings(*_); end

  def CSLSave(*_); end

  def CSLSetNameValue(*_); end

  def CSLSetNameValueSeparator(*_); end

  def CSLTestBoolean(*_); end

  def CSLTokenizeString(*_); end

  def CSLTokenizeString2(*_); end

  def CSLTokenizeStringComplex(*_); end
end

module FFI::CPL::String
  def self.CPLBase64DecodeInPlace(*_); end

  def self.CPLBase64Encode(*_); end

  def self.CPLBinaryToHex(*_); end

  def self.CPLClearRecodeWarningFlags(*_); end

  def self.CPLEncodingCharSize(*_); end

  def self.CPLEscapeString(*_); end

  def self.CPLForceToASCII(*_); end

  def self.CPLGetValueType(*_); end

  def self.CPLHexToBinary(*_); end

  def self.CPLIsUTF8(*_); end

  def self.CPLParseNameValue(*_); end

  def self.CPLRecode(*_); end

  def self.CPLRecodeFromWChar(*_); end

  def self.CPLRecodeToWChar(*_); end

  def self.CPLSPrintf(*args); end

  def self.CPLStrlcat(*_); end

  def self.CPLStrlcpy(*_); end

  def self.CPLStrlenUTF8(*_); end

  def self.CPLStrnlen(*_); end

  def self.CPLUnescapeString(*_); end

  def self.CPLVASPrintf(*args); end

  def self.CSLAddNameValue(*_); end

  def self.CSLAddString(*_); end

  def self.CSLAppendPrintf(*args); end

  def self.CSLCount(*_); end

  def self.CSLDestroy(*_); end

  def self.CSLDuplicate(*_); end

  def self.CSLFetchBoolean(*_); end

  def self.CSLFetchNameValue(*_); end

  def self.CSLFetchNameValueDef(*_); end

  def self.CSLFetchNameValueMultiple(*_); end

  def self.CSLFindName(*_); end

  def self.CSLFindString(*_); end

  def self.CSLGetField(*_); end

  def self.CSLInsertString(*_); end

  def self.CSLInsertStrings(*_); end

  def self.CSLLoad(*_); end

  def self.CSLLoad2(*_); end

  def self.CSLMerge(*_); end

  def self.CSLPartialFindString(*_); end

  def self.CSLPrint(*_); end

  def self.CSLRemoveStrings(*_); end

  def self.CSLSave(*_); end

  def self.CSLSetNameValue(*_); end

  def self.CSLSetNameValueSeparator(*_); end

  def self.CSLTestBoolean(*_); end

  def self.CSLTokenizeString(*_); end

  def self.CSLTokenizeString2(*_); end

  def self.CSLTokenizeStringComplex(*_); end
end

module FFI::CPL::VSI
  def VSICTime(*_); end

  def VSICalloc(*_); end

  def VSICleanupFileManager(*_); end

  def VSIFClose(*_); end

  def VSIFCloseL(*_); end

  def VSIFEof(*_); end

  def VSIFEofL(*_); end

  def VSIFFlush(*_); end

  def VSIFFlushL(*_); end

  def VSIFGetNativeFileDescriptorL(*_); end

  def VSIFGetc(*_); end

  def VSIFGets(*_); end

  def VSIFOpen(*_); end

  def VSIFOpenL(*_); end

  def VSIFPrintf(*args); end

  def VSIFPrintfL(*args); end

  def VSIFPutc(*_); end

  def VSIFPutcL(*_); end

  def VSIFPuts(*_); end

  def VSIFRead(*_); end

  def VSIFReadL(*_); end

  def VSIFReadMultiRangeL(*_); end

  def VSIFSeek(*_); end

  def VSIFSeekL(*_); end

  def VSIFTell(*_); end

  def VSIFTellL(*_); end

  def VSIFTruncateL(*_); end

  def VSIFWrite(*_); end

  def VSIFWriteL(*_); end

  def VSIFileFromMemBuffer(*_); end

  def VSIFree(*_); end

  def VSIGMTime(*_); end

  def VSIGetMemFileBuffer(*_); end

  def VSIIngestFile(*_); end

  def VSIInstallCurlFileHandler(*_); end

  def VSIInstallCurlStreamingFileHandler(*_); end

  def VSIInstallGZipFileHandler(*_); end

  def VSIInstallLargeFileHandler(*_); end

  def VSIInstallMemFileHandler(*_); end

  def VSIInstallSparseFileHandler(*_); end

  def VSIInstallStdinHandler(*_); end

  def VSIInstallStdoutHandler(*_); end

  def VSIInstallSubFileHandler(*_); end

  def VSIInstallTarFileHandler(*_); end

  def VSIInstallZipFileHandler(*_); end

  def VSIIsCaseSensitiveFS(*_); end

  def VSILocalTime(*_); end

  def VSIMalloc(*_); end

  def VSIMalloc2(*_); end

  def VSIMalloc3(*_); end

  def VSIMkdir(*_); end

  def VSIReadDir(*_); end

  def VSIReadDirRecursive(*_); end

  def VSIRealloc(*_); end

  def VSIRename(*_); end

  def VSIRewind(*_); end

  def VSIRewindL(*_); end

  def VSIRmdir(*_); end

  def VSIStat(*_); end

  def VSIStatExL(*_); end

  def VSIStatL(*_); end

  def VSIStdoutSetRedirection(*_); end

  def VSIStrdup(*_); end

  def VSIStrerror(*_); end

  def VSITime(*_); end

  def VSIUngetc(*_); end

  def VSIUnlink(*_); end
end

module FFI::CPL::VSI
  def self.VSICTime(*_); end

  def self.VSICalloc(*_); end

  def self.VSICleanupFileManager(*_); end

  def self.VSIFClose(*_); end

  def self.VSIFCloseL(*_); end

  def self.VSIFEof(*_); end

  def self.VSIFEofL(*_); end

  def self.VSIFFlush(*_); end

  def self.VSIFFlushL(*_); end

  def self.VSIFGetNativeFileDescriptorL(*_); end

  def self.VSIFGetc(*_); end

  def self.VSIFGets(*_); end

  def self.VSIFOpen(*_); end

  def self.VSIFOpenL(*_); end

  def self.VSIFPrintf(*args); end

  def self.VSIFPrintfL(*args); end

  def self.VSIFPutc(*_); end

  def self.VSIFPutcL(*_); end

  def self.VSIFPuts(*_); end

  def self.VSIFRead(*_); end

  def self.VSIFReadL(*_); end

  def self.VSIFReadMultiRangeL(*_); end

  def self.VSIFSeek(*_); end

  def self.VSIFSeekL(*_); end

  def self.VSIFTell(*_); end

  def self.VSIFTellL(*_); end

  def self.VSIFTruncateL(*_); end

  def self.VSIFWrite(*_); end

  def self.VSIFWriteL(*_); end

  def self.VSIFileFromMemBuffer(*_); end

  def self.VSIFree(*_); end

  def self.VSIGMTime(*_); end

  def self.VSIGetMemFileBuffer(*_); end

  def self.VSIIngestFile(*_); end

  def self.VSIInstallCurlFileHandler(*_); end

  def self.VSIInstallCurlStreamingFileHandler(*_); end

  def self.VSIInstallGZipFileHandler(*_); end

  def self.VSIInstallLargeFileHandler(*_); end

  def self.VSIInstallMemFileHandler(*_); end

  def self.VSIInstallSparseFileHandler(*_); end

  def self.VSIInstallStdinHandler(*_); end

  def self.VSIInstallStdoutHandler(*_); end

  def self.VSIInstallSubFileHandler(*_); end

  def self.VSIInstallTarFileHandler(*_); end

  def self.VSIInstallZipFileHandler(*_); end

  def self.VSIIsCaseSensitiveFS(*_); end

  def self.VSILocalTime(*_); end

  def self.VSIMalloc(*_); end

  def self.VSIMalloc2(*_); end

  def self.VSIMalloc3(*_); end

  def self.VSIMkdir(*_); end

  def self.VSIReadDir(*_); end

  def self.VSIReadDirRecursive(*_); end

  def self.VSIRealloc(*_); end

  def self.VSIRename(*_); end

  def self.VSIRewind(*_); end

  def self.VSIRewindL(*_); end

  def self.VSIRmdir(*_); end

  def self.VSIStat(*_); end

  def self.VSIStatExL(*_); end

  def self.VSIStatL(*_); end

  def self.VSIStdoutSetRedirection(*_); end

  def self.VSIStrdup(*_); end

  def self.VSIStrerror(*_); end

  def self.VSITime(*_); end

  def self.VSIUngetc(*_); end

  def self.VSIUnlink(*_); end
end

class FFI::CPL::XMLNode
end

FFI::CallbackInfo = FFI::FunctionType

class FFI::ConstGenerator
  def [](name); end

  def calculate(options=T.unsafe(nil)); end

  def const(name, format=T.unsafe(nil), cast=T.unsafe(nil), ruby_name=T.unsafe(nil), converter=T.unsafe(nil), &converter_proc); end

  def constants(); end

  def dump_constants(io); end

  def include(*i); end

  def initialize(prefix=T.unsafe(nil), options=T.unsafe(nil)); end

  def to_ruby(); end
end

class FFI::ConstGenerator::Constant
  def cast(); end

  def converted_value(); end

  def format(); end

  def initialize(name, format, cast, ruby_name=T.unsafe(nil), converter=T.unsafe(nil)); end

  def name(); end

  def ruby_name(); end

  def to_ruby(); end

  def value(); end

  def value=(value); end
end

class FFI::ConstGenerator::Constant
end

class FFI::ConstGenerator
  def self.options(); end

  def self.options=(options); end
end

module FFI::DataConverter
  def from_native(value, ctx); end

  def native_type(type=T.unsafe(nil)); end

  def to_native(value, ctx); end
end

module FFI::DataConverter
end

class FFI::DynamicLibrary
  def find_function(_); end

  def find_symbol(_); end

  def find_variable(_); end

  def initialize(_, _1); end

  def last_error(); end

  def name(); end
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary
  def self.last_error(); end

  def self.open(_, _1); end
end

class FFI::Enum
  include ::FFI::DataConverter
  def [](query); end

  def find(query); end

  def from_native(val, ctx); end

  def initialize(*args); end

  def native_type(); end

  def symbol_map(); end

  def symbols(); end

  def tag(); end

  def to_h(); end

  def to_hash(); end

  def to_native(val, ctx); end
end

class FFI::Enum
end

class FFI::Enums
  def <<(enum); end

  def __map_symbol(symbol); end

  def find(query); end
end

class FFI::Enums
end

class FFI::Function
  def attach(_, _1); end

  def autorelease(); end

  def call(*_); end
end

class FFI::Function
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType
  def initialize(*_); end

  def param_types(); end

  def result_type(); end
end

class FFI::FunctionType
end

module FFI::GDAL
  def GDALCheckVersion(*_); end

  def GDALVersionInfo(*_); end
end

module FFI::GDAL::Alg
  def GDALApproxTransform(*_); end

  def GDALApproxTransformerOwnsSubtransformer(*_); end

  def GDALChecksumImage(*_); end

  def GDALComputeMatchingPoints(*_); end

  def GDALComputeMedianCutPCT(*_); end

  def GDALComputeProximity(*_); end

  def GDALContourGenerate(*_); end

  def GDALCreateApproxTransformer(*_); end

  def GDALCreateGCPRefineTransformer(*_); end

  def GDALCreateGCPTransformer(*_); end

  def GDALCreateGenImgProjTransformer(*_); end

  def GDALCreateGenImgProjTransformer2(*_); end

  def GDALCreateGenImgProjTransformer3(*_); end

  def GDALCreateGeoLocTransformer(*_); end

  def GDALCreateRPCTransformer(*_); end

  def GDALCreateReprojectionTransformer(*_); end

  def GDALCreateTPSTransformer(*_); end

  def GDALDeserializeTransformer(*_); end

  def GDALDestroyApproxTransformer(*_); end

  def GDALDestroyGCPTransformer(*_); end

  def GDALDestroyGenImgProjTransformer(*_); end

  def GDALDestroyGeoLocTransformer(*_); end

  def GDALDestroyRPCTransformer(*_); end

  def GDALDestroyReprojectionTransformer(*_); end

  def GDALDestroyTPSTransformer(*_); end

  def GDALDestroyTransformer(*_); end

  def GDALDitherRGB2PCT(*_); end

  def GDALFPolygonize(*_); end

  def GDALFillNodata(*_); end

  def GDALGCPTransform(*_); end

  def GDALGenImgProjTransform(*_); end

  def GDALGeoLocTransform(*_); end

  def GDALGridCreate(*_); end

  def GDALPolygonize(*_); end

  def GDALRPCTransform(*_); end

  def GDALRasterizeGeometries(*_); end

  def GDALRasterizeLayers(*_); end

  def GDALRasterizeLayersBuf(*_); end

  def GDALReprojectionTransform(*_); end

  def GDALSerializeTransformer(*_); end

  def GDALSetGenImgProjTransformerDstGeoTransform(*_); end

  def GDALSieveFilter(*_); end

  def GDALSimpleImageWarp(*_); end

  def GDALSuggestedWarpOutput(*_); end

  def GDALSuggestedWarpOutput2(*_); end

  def GDALTPSTransform(*_); end

  def GDALTransformGeolocations(*_); end

  def GDAL_CG_Create(*_); end

  def GDAL_CG_Destroy(*_); end

  def GDAL_CG_FeedLine(*_); end

  def OGRContourWriter(*_); end

  def RPCInfoToMD(*_); end
end

module FFI::GDAL::Alg
  def self.GDALApproxTransform(*_); end

  def self.GDALApproxTransformerOwnsSubtransformer(*_); end

  def self.GDALChecksumImage(*_); end

  def self.GDALComputeMatchingPoints(*_); end

  def self.GDALComputeMedianCutPCT(*_); end

  def self.GDALComputeProximity(*_); end

  def self.GDALContourGenerate(*_); end

  def self.GDALCreateApproxTransformer(*_); end

  def self.GDALCreateGCPRefineTransformer(*_); end

  def self.GDALCreateGCPTransformer(*_); end

  def self.GDALCreateGenImgProjTransformer(*_); end

  def self.GDALCreateGenImgProjTransformer2(*_); end

  def self.GDALCreateGenImgProjTransformer3(*_); end

  def self.GDALCreateGeoLocTransformer(*_); end

  def self.GDALCreateRPCTransformer(*_); end

  def self.GDALCreateReprojectionTransformer(*_); end

  def self.GDALCreateTPSTransformer(*_); end

  def self.GDALDeserializeTransformer(*_); end

  def self.GDALDestroyApproxTransformer(*_); end

  def self.GDALDestroyGCPTransformer(*_); end

  def self.GDALDestroyGenImgProjTransformer(*_); end

  def self.GDALDestroyGeoLocTransformer(*_); end

  def self.GDALDestroyRPCTransformer(*_); end

  def self.GDALDestroyReprojectionTransformer(*_); end

  def self.GDALDestroyTPSTransformer(*_); end

  def self.GDALDestroyTransformer(*_); end

  def self.GDALDitherRGB2PCT(*_); end

  def self.GDALFPolygonize(*_); end

  def self.GDALFillNodata(*_); end

  def self.GDALGCPTransform(*_); end

  def self.GDALGenImgProjTransform(*_); end

  def self.GDALGeoLocTransform(*_); end

  def self.GDALGridCreate(*_); end

  def self.GDALPolygonize(*_); end

  def self.GDALRPCTransform(*_); end

  def self.GDALRasterizeGeometries(*_); end

  def self.GDALRasterizeLayers(*_); end

  def self.GDALRasterizeLayersBuf(*_); end

  def self.GDALReprojectionTransform(*_); end

  def self.GDALSerializeTransformer(*_); end

  def self.GDALSetGenImgProjTransformerDstGeoTransform(*_); end

  def self.GDALSieveFilter(*_); end

  def self.GDALSimpleImageWarp(*_); end

  def self.GDALSuggestedWarpOutput(*_); end

  def self.GDALSuggestedWarpOutput2(*_); end

  def self.GDALTPSTransform(*_); end

  def self.GDALTransformGeolocations(*_); end

  def self.GDAL_CG_Create(*_); end

  def self.GDAL_CG_Destroy(*_); end

  def self.GDAL_CG_FeedLine(*_); end

  def self.OGRContourWriter(*_); end

  def self.RPCInfoToMD(*_); end
end

class FFI::GDAL::ColorEntry
end

class FFI::GDAL::GCP
end

module FFI::GDAL::GDAL
  def GDALAddBand(*_); end

  def GDALAddDerivedBandPixelFunc(*_); end

  def GDALAllRegister(*_); end

  def GDALApplyGeoTransform(*_); end

  def GDALBeginAsyncReader(*_); end

  def GDALBuildOverviews(*_); end

  def GDALCloneColorTable(*_); end

  def GDALClose(*_); end

  def GDALComposeGeoTransforms(*_); end

  def GDALComputeRasterMinMax(*_); end

  def GDALComputeRasterStatistics(*_); end

  def GDALCopyBits(*_); end

  def GDALCopyDatasetFiles(*_); end

  def GDALCopyWords(*_); end

  def GDALCreate(*_); end

  def GDALCreateColorRamp(*_); end

  def GDALCreateColorTable(*_); end

  def GDALCreateCopy(*_); end

  def GDALCreateDatasetMaskBand(*_); end

  def GDALCreateMaskBand(*_); end

  def GDALCreateRasterAttributeTable(*_); end

  def GDALDataTypeIsComplex(*_); end

  def GDALDataTypeUnion(*_); end

  def GDALDatasetAdviseRead(*_); end

  def GDALDatasetCopyWholeRaster(*_); end

  def GDALDatasetRasterIO(*_); end

  def GDALDecToPackedDMS(*_); end

  def GDALDeinitGCPs(*_); end

  def GDALDeleteDataset(*_); end

  def GDALDereferenceDataset(*_); end

  def GDALDeregisterDriver(*_); end

  def GDALDestroyColorTable(*_); end

  def GDALDestroyDriver(*_); end

  def GDALDestroyDriverManager(*_); end

  def GDALDestroyRasterAttributeTable(*_); end

  def GDALDumpOpenDatasets(*_); end

  def GDALDuplicateGCPs(*_); end

  def GDALEndAsyncReader(*_); end

  def GDALFillRaster(*_); end

  def GDALFlushCache(*_); end

  def GDALFlushCacheBlock(*_); end

  def GDALFlushRasterCache(*_); end

  def GDALGCPsToGeoTransform(*_); end

  def GDALGeneralCmdLineProcessor(*_); end

  def GDALGetAccess(*_); end

  def GDALGetAsyncStatusTypeByName(*_); end

  def GDALGetAsyncStatusTypeName(*_); end

  def GDALGetBandDataset(*_); end

  def GDALGetBandNumber(*_); end

  def GDALGetBlockSize(*_); end

  def GDALGetCacheMax(*_); end

  def GDALGetCacheMax64(*_); end

  def GDALGetCacheUsed(*_); end

  def GDALGetCacheUsed64(*_); end

  def GDALGetColorEntry(*_); end

  def GDALGetColorEntryAsRGB(*_); end

  def GDALGetColorEntryCount(*_); end

  def GDALGetColorInterpretationByName(*_); end

  def GDALGetColorInterpretationName(*_); end

  def GDALGetDataTypeByName(*_); end

  def GDALGetDataTypeName(*_); end

  def GDALGetDataTypeSize(*_); end

  def GDALGetDatasetDriver(*_); end

  def GDALGetDefaultHistogram(*_); end

  def GDALGetDefaultRAT(*_); end

  def GDALGetDescription(*_); end

  def GDALGetDriver(*_); end

  def GDALGetDriverByName(*_); end

  def GDALGetDriverCount(*_); end

  def GDALGetDriverCreationOptionList(*_); end

  def GDALGetDriverHelpTopic(*_); end

  def GDALGetDriverLongName(*_); end

  def GDALGetDriverShortName(*_); end

  def GDALGetFileList(*_); end

  def GDALGetGCPCount(*_); end

  def GDALGetGCPProjection(*_); end

  def GDALGetGCPs(*_); end

  def GDALGetGeoTransform(*_); end

  def GDALGetInternalHandle(*_); end

  def GDALGetMaskBand(*_); end

  def GDALGetMaskFlags(*_); end

  def GDALGetMetadata(*_); end

  def GDALGetMetadataDomainList(*_); end

  def GDALGetMetadataItem(*_); end

  def GDALGetOpenDatasets(*_); end

  def GDALGetOverview(*_); end

  def GDALGetOverviewCount(*_); end

  def GDALGetPaletteInterpretation(*_); end

  def GDALGetPaletteInterpretationName(*_); end

  def GDALGetProjectionRef(*_); end

  def GDALGetRandomRasterSample(*_); end

  def GDALGetRasterAccess(*_); end

  def GDALGetRasterBand(*_); end

  def GDALGetRasterBandXSize(*_); end

  def GDALGetRasterBandYSize(*_); end

  def GDALGetRasterCategoryNames(*_); end

  def GDALGetRasterColorInterpretation(*_); end

  def GDALGetRasterColorTable(*_); end

  def GDALGetRasterCount(*_); end

  def GDALGetRasterDataType(*_); end

  def GDALGetRasterHistogram(*_); end

  def GDALGetRasterMaximum(*_); end

  def GDALGetRasterMinimum(*_); end

  def GDALGetRasterNoDataValue(*_); end

  def GDALGetRasterOffset(*_); end

  def GDALGetRasterSampleOverview(*_); end

  def GDALGetRasterScale(*_); end

  def GDALGetRasterStatistics(*_); end

  def GDALGetRasterUnitType(*_); end

  def GDALGetRasterXSize(*_); end

  def GDALGetRasterYSize(*_); end

  def GDALHasArbitraryOverviews(*_); end

  def GDALIdentifyDriver(*_); end

  def GDALInitGCPs(*_); end

  def GDALInvGeoTransform(*_); end

  def GDALLoadWorldFile(*_); end

  def GDALOpen(*_); end

  def GDALOpenShared(*_); end

  def GDALPackedDMSToDec(*_); end

  def GDALRATChangesAreWrittenToFile(*_); end

  def GDALRATClone(*_); end

  def GDALRATCreateColumn(*_); end

  def GDALRATDumpReadable(*_); end

  def GDALRATGetColOfUsage(*_); end

  def GDALRATGetColumnCount(*_); end

  def GDALRATGetLinearBinning(*_); end

  def GDALRATGetNameOfCol(*_); end

  def GDALRATGetRowCount(*_); end

  def GDALRATGetRowOfValue(*_); end

  def GDALRATGetTypeOfCol(*_); end

  def GDALRATGetUsageOfCol(*_); end

  def GDALRATGetValueAsDouble(*_); end

  def GDALRATGetValueAsInt(*_); end

  def GDALRATGetValueAsString(*_); end

  def GDALRATInitializeFromColorTable(*_); end

  def GDALRATSetLinearBinning(*_); end

  def GDALRATSetRowCount(*_); end

  def GDALRATSetValueAsDouble(*_); end

  def GDALRATSetValueAsInt(*_); end

  def GDALRATSetValueAsString(*_); end

  def GDALRATTranslateToColorTable(*_); end

  def GDALRATValuesIOAsDouble(*_); end

  def GDALRATValuesIOAsInteger(*_); end

  def GDALRATValuesIOAsString(*_); end

  def GDALRasterAdviseRead(*_); end

  def GDALRasterBandCopyWholeRaster(*_); end

  def GDALRasterIO(*_); end

  def GDALReadBlock(*_); end

  def GDALReadWorldFile(*_); end

  def GDALReferenceDataset(*_); end

  def GDALRegenerateOverviews(*_); end

  def GDALRegisterDriver(*_); end

  def GDALRenameDataset(*_); end

  def GDALSetCacheMax(*_); end

  def GDALSetCacheMax64(*_); end

  def GDALSetColorEntry(*_); end

  def GDALSetDefaultHistogram(*_); end

  def GDALSetDefaultRAT(*_); end

  def GDALSetDescription(*_); end

  def GDALSetGCPs(*_); end

  def GDALSetGeoTransform(*_); end

  def GDALSetMetadata(*_); end

  def GDALSetMetadataItem(*_); end

  def GDALSetProjection(*_); end

  def GDALSetRasterCategoryNames(*_); end

  def GDALSetRasterColorInterpretation(*_); end

  def GDALSetRasterColorTable(*_); end

  def GDALSetRasterNoDataValue(*_); end

  def GDALSetRasterOffset(*_); end

  def GDALSetRasterScale(*_); end

  def GDALSetRasterStatistics(*_); end

  def GDALSetRasterUnitType(*_); end

  def GDALSwapWords(*_); end

  def GDALValidateCreationOptions(*_); end

  def GDALWriteBlock(*_); end

  def GDALWriteWorldFile(*_); end
end

module FFI::GDAL::GDAL
  def self.GDALAddBand(*_); end

  def self.GDALAddDerivedBandPixelFunc(*_); end

  def self.GDALAllRegister(*_); end

  def self.GDALApplyGeoTransform(*_); end

  def self.GDALBeginAsyncReader(*_); end

  def self.GDALBuildOverviews(*_); end

  def self.GDALCloneColorTable(*_); end

  def self.GDALClose(*_); end

  def self.GDALComposeGeoTransforms(*_); end

  def self.GDALComputeRasterMinMax(*_); end

  def self.GDALComputeRasterStatistics(*_); end

  def self.GDALCopyBits(*_); end

  def self.GDALCopyDatasetFiles(*_); end

  def self.GDALCopyWords(*_); end

  def self.GDALCreate(*_); end

  def self.GDALCreateColorRamp(*_); end

  def self.GDALCreateColorTable(*_); end

  def self.GDALCreateCopy(*_); end

  def self.GDALCreateDatasetMaskBand(*_); end

  def self.GDALCreateMaskBand(*_); end

  def self.GDALCreateRasterAttributeTable(*_); end

  def self.GDALDataTypeIsComplex(*_); end

  def self.GDALDataTypeUnion(*_); end

  def self.GDALDatasetAdviseRead(*_); end

  def self.GDALDatasetCopyWholeRaster(*_); end

  def self.GDALDatasetRasterIO(*_); end

  def self.GDALDecToPackedDMS(*_); end

  def self.GDALDeinitGCPs(*_); end

  def self.GDALDeleteDataset(*_); end

  def self.GDALDereferenceDataset(*_); end

  def self.GDALDeregisterDriver(*_); end

  def self.GDALDestroyColorTable(*_); end

  def self.GDALDestroyDriver(*_); end

  def self.GDALDestroyDriverManager(*_); end

  def self.GDALDestroyRasterAttributeTable(*_); end

  def self.GDALDumpOpenDatasets(*_); end

  def self.GDALDuplicateGCPs(*_); end

  def self.GDALEndAsyncReader(*_); end

  def self.GDALFillRaster(*_); end

  def self.GDALFlushCache(*_); end

  def self.GDALFlushCacheBlock(*_); end

  def self.GDALFlushRasterCache(*_); end

  def self.GDALGCPsToGeoTransform(*_); end

  def self.GDALGeneralCmdLineProcessor(*_); end

  def self.GDALGetAccess(*_); end

  def self.GDALGetAsyncStatusTypeByName(*_); end

  def self.GDALGetAsyncStatusTypeName(*_); end

  def self.GDALGetBandDataset(*_); end

  def self.GDALGetBandNumber(*_); end

  def self.GDALGetBlockSize(*_); end

  def self.GDALGetCacheMax(*_); end

  def self.GDALGetCacheMax64(*_); end

  def self.GDALGetCacheUsed(*_); end

  def self.GDALGetCacheUsed64(*_); end

  def self.GDALGetColorEntry(*_); end

  def self.GDALGetColorEntryAsRGB(*_); end

  def self.GDALGetColorEntryCount(*_); end

  def self.GDALGetColorInterpretationByName(*_); end

  def self.GDALGetColorInterpretationName(*_); end

  def self.GDALGetDataTypeByName(*_); end

  def self.GDALGetDataTypeName(*_); end

  def self.GDALGetDataTypeSize(*_); end

  def self.GDALGetDatasetDriver(*_); end

  def self.GDALGetDefaultHistogram(*_); end

  def self.GDALGetDefaultRAT(*_); end

  def self.GDALGetDescription(*_); end

  def self.GDALGetDriver(*_); end

  def self.GDALGetDriverByName(*_); end

  def self.GDALGetDriverCount(*_); end

  def self.GDALGetDriverCreationOptionList(*_); end

  def self.GDALGetDriverHelpTopic(*_); end

  def self.GDALGetDriverLongName(*_); end

  def self.GDALGetDriverShortName(*_); end

  def self.GDALGetFileList(*_); end

  def self.GDALGetGCPCount(*_); end

  def self.GDALGetGCPProjection(*_); end

  def self.GDALGetGCPs(*_); end

  def self.GDALGetGeoTransform(*_); end

  def self.GDALGetInternalHandle(*_); end

  def self.GDALGetMaskBand(*_); end

  def self.GDALGetMaskFlags(*_); end

  def self.GDALGetMetadata(*_); end

  def self.GDALGetMetadataDomainList(*_); end

  def self.GDALGetMetadataItem(*_); end

  def self.GDALGetOpenDatasets(*_); end

  def self.GDALGetOverview(*_); end

  def self.GDALGetOverviewCount(*_); end

  def self.GDALGetPaletteInterpretation(*_); end

  def self.GDALGetPaletteInterpretationName(*_); end

  def self.GDALGetProjectionRef(*_); end

  def self.GDALGetRandomRasterSample(*_); end

  def self.GDALGetRasterAccess(*_); end

  def self.GDALGetRasterBand(*_); end

  def self.GDALGetRasterBandXSize(*_); end

  def self.GDALGetRasterBandYSize(*_); end

  def self.GDALGetRasterCategoryNames(*_); end

  def self.GDALGetRasterColorInterpretation(*_); end

  def self.GDALGetRasterColorTable(*_); end

  def self.GDALGetRasterCount(*_); end

  def self.GDALGetRasterDataType(*_); end

  def self.GDALGetRasterHistogram(*_); end

  def self.GDALGetRasterMaximum(*_); end

  def self.GDALGetRasterMinimum(*_); end

  def self.GDALGetRasterNoDataValue(*_); end

  def self.GDALGetRasterOffset(*_); end

  def self.GDALGetRasterSampleOverview(*_); end

  def self.GDALGetRasterScale(*_); end

  def self.GDALGetRasterStatistics(*_); end

  def self.GDALGetRasterUnitType(*_); end

  def self.GDALGetRasterXSize(*_); end

  def self.GDALGetRasterYSize(*_); end

  def self.GDALHasArbitraryOverviews(*_); end

  def self.GDALIdentifyDriver(*_); end

  def self.GDALInitGCPs(*_); end

  def self.GDALInvGeoTransform(*_); end

  def self.GDALLoadWorldFile(*_); end

  def self.GDALOpen(*_); end

  def self.GDALOpenShared(*_); end

  def self.GDALPackedDMSToDec(*_); end

  def self.GDALRATChangesAreWrittenToFile(*_); end

  def self.GDALRATClone(*_); end

  def self.GDALRATCreateColumn(*_); end

  def self.GDALRATDumpReadable(*_); end

  def self.GDALRATGetColOfUsage(*_); end

  def self.GDALRATGetColumnCount(*_); end

  def self.GDALRATGetLinearBinning(*_); end

  def self.GDALRATGetNameOfCol(*_); end

  def self.GDALRATGetRowCount(*_); end

  def self.GDALRATGetRowOfValue(*_); end

  def self.GDALRATGetTypeOfCol(*_); end

  def self.GDALRATGetUsageOfCol(*_); end

  def self.GDALRATGetValueAsDouble(*_); end

  def self.GDALRATGetValueAsInt(*_); end

  def self.GDALRATGetValueAsString(*_); end

  def self.GDALRATInitializeFromColorTable(*_); end

  def self.GDALRATSetLinearBinning(*_); end

  def self.GDALRATSetRowCount(*_); end

  def self.GDALRATSetValueAsDouble(*_); end

  def self.GDALRATSetValueAsInt(*_); end

  def self.GDALRATSetValueAsString(*_); end

  def self.GDALRATTranslateToColorTable(*_); end

  def self.GDALRATValuesIOAsDouble(*_); end

  def self.GDALRATValuesIOAsInteger(*_); end

  def self.GDALRATValuesIOAsString(*_); end

  def self.GDALRasterAdviseRead(*_); end

  def self.GDALRasterBandCopyWholeRaster(*_); end

  def self.GDALRasterIO(*_); end

  def self.GDALReadBlock(*_); end

  def self.GDALReadWorldFile(*_); end

  def self.GDALReferenceDataset(*_); end

  def self.GDALRegenerateOverviews(*_); end

  def self.GDALRegisterDriver(*_); end

  def self.GDALRenameDataset(*_); end

  def self.GDALSetCacheMax(*_); end

  def self.GDALSetCacheMax64(*_); end

  def self.GDALSetColorEntry(*_); end

  def self.GDALSetDefaultHistogram(*_); end

  def self.GDALSetDefaultRAT(*_); end

  def self.GDALSetDescription(*_); end

  def self.GDALSetGCPs(*_); end

  def self.GDALSetGeoTransform(*_); end

  def self.GDALSetMetadata(*_); end

  def self.GDALSetMetadataItem(*_); end

  def self.GDALSetProjection(*_); end

  def self.GDALSetRasterCategoryNames(*_); end

  def self.GDALSetRasterColorInterpretation(*_); end

  def self.GDALSetRasterColorTable(*_); end

  def self.GDALSetRasterNoDataValue(*_); end

  def self.GDALSetRasterOffset(*_); end

  def self.GDALSetRasterScale(*_); end

  def self.GDALSetRasterStatistics(*_); end

  def self.GDALSetRasterUnitType(*_); end

  def self.GDALSwapWords(*_); end

  def self.GDALValidateCreationOptions(*_); end

  def self.GDALWriteBlock(*_); end

  def self.GDALWriteWorldFile(*_); end
end

module FFI::GDAL::Grid
  def GDALGridDataMetricAverageDistance(*_); end

  def GDALGridDataMetricAverageDistancePts(*_); end

  def GDALGridDataMetricCount(*_); end

  def GDALGridDataMetricMaximum(*_); end

  def GDALGridDataMetricMinimum(*_); end

  def GDALGridDataMetricRange(*_); end

  def GDALGridInverseDistanceToAPower(*_); end

  def GDALGridMovingAverage(*_); end

  def GDALGridNearestNeighbor(*_); end

  def ParseAlgorithmAndOptions(*_); end
end

module FFI::GDAL::Grid
  def self.GDALGridDataMetricAverageDistance(*_); end

  def self.GDALGridDataMetricAverageDistancePts(*_); end

  def self.GDALGridDataMetricCount(*_); end

  def self.GDALGridDataMetricMaximum(*_); end

  def self.GDALGridDataMetricMinimum(*_); end

  def self.GDALGridDataMetricRange(*_); end

  def self.GDALGridInverseDistanceToAPower(*_); end

  def self.GDALGridMovingAverage(*_); end

  def self.GDALGridNearestNeighbor(*_); end

  def self.ParseAlgorithmAndOptions(*_); end
end

class FFI::GDAL::GridDataMetricsOptions
end

class FFI::GDAL::GridInverseDistanceToAPowerOptions
end

class FFI::GDAL::GridMovingAverageOptions
end

class FFI::GDAL::GridNearestNeighborOptions
end

module FFI::GDAL::Matching
  def GDALComputeMatchingPoints(*_); end
end

module FFI::GDAL::Matching
  def self.GDALComputeMatchingPoints(*_); end
end

class FFI::GDAL::RPCInfo
end

class FFI::GDAL::TransformerInfo
end

module FFI::GDAL::VRT
  def GDALRegister_VRT(*_); end

  def VRTAddBand(*_); end

  def VRTAddComplexSource(*_); end

  def VRTAddFuncSource(*_); end

  def VRTAddSimpleSource(*_); end

  def VRTAddSource(*_); end

  def VRTCreate(*_); end

  def VRTFlushCache(*_); end

  def VRTSerializeToXML(*_); end
end

module FFI::GDAL::VRT
  def self.GDALRegister_VRT(*_); end

  def self.VRTAddBand(*_); end

  def self.VRTAddComplexSource(*_); end

  def self.VRTAddFuncSource(*_); end

  def self.VRTAddSimpleSource(*_); end

  def self.VRTAddSource(*_); end

  def self.VRTCreate(*_); end

  def self.VRTFlushCache(*_); end

  def self.VRTSerializeToXML(*_); end
end

class FFI::GDAL::WarpOptions
end

module FFI::GDAL::Warper
  def GDALAutoCreateWarpedVRT(*_); end

  def GDALChunkAndWarpImage(*_); end

  def GDALChunkAndWarpMulti(*_); end

  def GDALCloneWarpOptions(*_); end

  def GDALCreateAndReprojectImage(*_); end

  def GDALCreateWarpOperation(*_); end

  def GDALCreateWarpOptions(*_); end

  def GDALCreateWarpedVRT(*_); end

  def GDALDeserializeWarpOptions(*_); end

  def GDALDestroyWarpOperation(*_); end

  def GDALDestroyWarpOptions(*_); end

  def GDALInitializeWarpedVRT(*_); end

  def GDALReprojectImage(*_); end

  def GDALSerializeWarpOptions(*_); end

  def GDALWarpCutlineMasker(*_); end

  def GDALWarpDstAlphaMasker(*_); end

  def GDALWarpNoDataMasker(*_); end

  def GDALWarpRegion(*_); end

  def GDALWarpRegionToBuffer(*_); end

  def GDALWarpSrcAlphaMasker(*_); end

  def GDALWarpSrcMaskMasker(*_); end
end

module FFI::GDAL::Warper
  def self.GDALAutoCreateWarpedVRT(*_); end

  def self.GDALChunkAndWarpImage(*_); end

  def self.GDALChunkAndWarpMulti(*_); end

  def self.GDALCloneWarpOptions(*_); end

  def self.GDALCreateAndReprojectImage(*_); end

  def self.GDALCreateWarpOperation(*_); end

  def self.GDALCreateWarpOptions(*_); end

  def self.GDALCreateWarpedVRT(*_); end

  def self.GDALDeserializeWarpOptions(*_); end

  def self.GDALDestroyWarpOperation(*_); end

  def self.GDALDestroyWarpOptions(*_); end

  def self.GDALInitializeWarpedVRT(*_); end

  def self.GDALReprojectImage(*_); end

  def self.GDALSerializeWarpOptions(*_); end

  def self.GDALWarpCutlineMasker(*_); end

  def self.GDALWarpDstAlphaMasker(*_); end

  def self.GDALWarpNoDataMasker(*_); end

  def self.GDALWarpRegion(*_); end

  def self.GDALWarpRegionToBuffer(*_); end

  def self.GDALWarpSrcAlphaMasker(*_); end

  def self.GDALWarpSrcMaskMasker(*_); end
end

module FFI::GDAL
  def self.GDALCheckVersion(*_); end

  def self.GDALVersionInfo(*_); end
end

module FFI::IO
end

module FFI::IO
  def self.for_fd(fd, mode=T.unsafe(nil)); end

  def self.native_read(io, buf, len); end
end

module FFI::LastError
end

module FFI::LastError
  def self.error(); end

  def self.error=(error); end
end

module FFI::Library
  def attach_variable(mname, a1, a2=T.unsafe(nil)); end

  def bitmask(*args); end

  def callback(*args); end

  def enum(*args); end

  def enum_type(name); end

  def enum_value(symbol); end

  def ffi_convention(convention=T.unsafe(nil)); end

  def ffi_lib(*names); end

  def ffi_lib_flags(*flags); end

  def ffi_libraries(); end

  def find_type(t); end

  def function_names(name, arg_types); end

  def typedef(old, add, info=T.unsafe(nil)); end
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

module FFI::Library
  def self.extended(mod); end
end

class FFI::ManagedStruct
  def initialize(pointer=T.unsafe(nil)); end
end

class FFI::ManagedStruct
end

class FFI::MemoryPointer
end

class FFI::MemoryPointer
  def self.from_string(_); end
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NotFoundError
  def initialize(function, *libraries); end
end

class FFI::NotFoundError
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::OGR::API
  def OGRBuildPolygonFromEdges(*_); end

  def OGRCleanupAll(*_); end

  def OGRDeregisterDriver(*_); end

  def OGRGetDriver(*_); end

  def OGRGetDriverByName(*_); end

  def OGRGetDriverCount(*_); end

  def OGRGetOpenDS(*_); end

  def OGRGetOpenDSCount(*_); end

  def OGROpen(*_); end

  def OGROpenShared(*_); end

  def OGRRegisterAll(*_); end

  def OGRRegisterDriver(*_); end

  def OGRReleaseDataSource(*_); end

  def OGR_DS_CopyLayer(*_); end

  def OGR_DS_CreateLayer(*_); end

  def OGR_DS_DeleteLayer(*_); end

  def OGR_DS_Destroy(*_); end

  def OGR_DS_ExecuteSQL(*_); end

  def OGR_DS_GetDriver(*_); end

  def OGR_DS_GetLayer(*_); end

  def OGR_DS_GetLayerByName(*_); end

  def OGR_DS_GetLayerCount(*_); end

  def OGR_DS_GetName(*_); end

  def OGR_DS_GetStyleTable(*_); end

  def OGR_DS_ReleaseResultSet(*_); end

  def OGR_DS_SetStyleTable(*_); end

  def OGR_DS_SetStyleTableDirectly(*_); end

  def OGR_DS_SyncToDisk(*_); end

  def OGR_DS_TestCapability(*_); end

  def OGR_Dr_CopyDataSource(*_); end

  def OGR_Dr_CreateDataSource(*_); end

  def OGR_Dr_DeleteDataSource(*_); end

  def OGR_Dr_GetName(*_); end

  def OGR_Dr_Open(*_); end

  def OGR_Dr_TestCapability(*_); end

  def OGR_FD_AddFieldDefn(*_); end

  def OGR_FD_AddGeomFieldDefn(*_); end

  def OGR_FD_Create(*_); end

  def OGR_FD_DeleteFieldDefn(*_); end

  def OGR_FD_DeleteGeomFieldDefn(*_); end

  def OGR_FD_Dereference(*_); end

  def OGR_FD_Destroy(*_); end

  def OGR_FD_GetFieldCount(*_); end

  def OGR_FD_GetFieldDefn(*_); end

  def OGR_FD_GetFieldIndex(*_); end

  def OGR_FD_GetGeomFieldCount(*_); end

  def OGR_FD_GetGeomFieldDefn(*_); end

  def OGR_FD_GetGeomFieldIndex(*_); end

  def OGR_FD_GetGeomType(*_); end

  def OGR_FD_GetName(*_); end

  def OGR_FD_GetReferenceCount(*_); end

  def OGR_FD_IsGeometryIgnored(*_); end

  def OGR_FD_IsSame(*_); end

  def OGR_FD_IsStyleIgnored(*_); end

  def OGR_FD_Reference(*_); end

  def OGR_FD_Release(*_); end

  def OGR_FD_SetGeomType(*_); end

  def OGR_FD_SetGeometryIgnored(*_); end

  def OGR_FD_SetStyleIgnored(*_); end

  def OGR_F_Clone(*_); end

  def OGR_F_Create(*_); end

  def OGR_F_Destroy(*_); end

  def OGR_F_DumpReadable(*_); end

  def OGR_F_Equal(*_); end

  def OGR_F_GetDefnRef(*_); end

  def OGR_F_GetFID(*_); end

  def OGR_F_GetFieldAsBinary(*_); end

  def OGR_F_GetFieldAsDateTime(*_); end

  def OGR_F_GetFieldAsDouble(*_); end

  def OGR_F_GetFieldAsDoubleList(*_); end

  def OGR_F_GetFieldAsInteger(*_); end

  def OGR_F_GetFieldAsIntegerList(*_); end

  def OGR_F_GetFieldAsString(*_); end

  def OGR_F_GetFieldAsStringList(*_); end

  def OGR_F_GetFieldCount(*_); end

  def OGR_F_GetFieldDefnRef(*_); end

  def OGR_F_GetFieldIndex(*_); end

  def OGR_F_GetGeomFieldCount(*_); end

  def OGR_F_GetGeomFieldDefnRef(*_); end

  def OGR_F_GetGeomFieldIndex(*_); end

  def OGR_F_GetGeomFieldRef(*_); end

  def OGR_F_GetGeometryRef(*_); end

  def OGR_F_GetRawFieldRef(*_); end

  def OGR_F_GetStyleString(*_); end

  def OGR_F_GetStyleTable(*_); end

  def OGR_F_IsFieldSet(*_); end

  def OGR_F_SetFID(*_); end

  def OGR_F_SetFieldBinary(*_); end

  def OGR_F_SetFieldDateTime(*_); end

  def OGR_F_SetFieldDouble(*_); end

  def OGR_F_SetFieldDoubleList(*_); end

  def OGR_F_SetFieldInteger(*_); end

  def OGR_F_SetFieldIntegerList(*_); end

  def OGR_F_SetFieldRaw(*_); end

  def OGR_F_SetFieldString(*_); end

  def OGR_F_SetFieldStringList(*_); end

  def OGR_F_SetFrom(*_); end

  def OGR_F_SetFromWithMap(*_); end

  def OGR_F_SetGeomField(*_); end

  def OGR_F_SetGeomFieldDirectly(*_); end

  def OGR_F_SetGeometry(*_); end

  def OGR_F_SetGeometryDirectly(*_); end

  def OGR_F_SetStyleString(*_); end

  def OGR_F_SetStyleStringDirectly(*_); end

  def OGR_F_SetStyleTable(*_); end

  def OGR_F_SetStyleTableDirectly(*_); end

  def OGR_F_StealGeometry(*_); end

  def OGR_F_UnsetField(*_); end

  def OGR_Fld_Create(*_); end

  def OGR_Fld_Destroy(*_); end

  def OGR_Fld_GetJustify(*_); end

  def OGR_Fld_GetNameRef(*_); end

  def OGR_Fld_GetPrecision(*_); end

  def OGR_Fld_GetType(*_); end

  def OGR_Fld_GetWidth(*_); end

  def OGR_Fld_IsIgnored(*_); end

  def OGR_Fld_Set(*_); end

  def OGR_Fld_SetIgnored(*_); end

  def OGR_Fld_SetJustify(*_); end

  def OGR_Fld_SetName(*_); end

  def OGR_Fld_SetPrecision(*_); end

  def OGR_Fld_SetType(*_); end

  def OGR_Fld_SetWidth(*_); end

  def OGR_GFld_Create(*_); end

  def OGR_GFld_Destroy(*_); end

  def OGR_GFld_GetNameRef(*_); end

  def OGR_GFld_GetSpatialRef(*_); end

  def OGR_GFld_GetType(*_); end

  def OGR_GFld_IsIgnored(*_); end

  def OGR_GFld_SetIgnored(*_); end

  def OGR_GFld_SetName(*_); end

  def OGR_GFld_SetSpatialRef(*_); end

  def OGR_GFld_SetType(*_); end

  def OGR_G_AddGeometry(*_); end

  def OGR_G_AddGeometryDirectly(*_); end

  def OGR_G_AddPoint(*_); end

  def OGR_G_AddPoint_2D(*_); end

  def OGR_G_ApproximateArcAngles(*_); end

  def OGR_G_Area(*_); end

  def OGR_G_AssignSpatialReference(*_); end

  def OGR_G_Boundary(*_); end

  def OGR_G_Buffer(*_); end

  def OGR_G_Centroid(*_); end

  def OGR_G_Clone(*_); end

  def OGR_G_CloseRings(*_); end

  def OGR_G_Contains(*_); end

  def OGR_G_ConvexHull(*_); end

  def OGR_G_CreateFromFgf(*_); end

  def OGR_G_CreateFromGML(*_); end

  def OGR_G_CreateFromGMLTree(*_); end

  def OGR_G_CreateFromWkb(*_); end

  def OGR_G_CreateFromWkt(*_); end

  def OGR_G_CreateGeometry(*_); end

  def OGR_G_CreateGeometryFromJson(*_); end

  def OGR_G_Crosses(*_); end

  def OGR_G_DestroyGeometry(*_); end

  def OGR_G_Difference(*_); end

  def OGR_G_Disjoint(*_); end

  def OGR_G_Distance(*_); end

  def OGR_G_DumpReadable(*_); end

  def OGR_G_Empty(*_); end

  def OGR_G_Equals(*_); end

  def OGR_G_ExportEnvelopeToGMLTree(*_); end

  def OGR_G_ExportToGML(*_); end

  def OGR_G_ExportToGMLEx(*_); end

  def OGR_G_ExportToGMLTree(*_); end

  def OGR_G_ExportToJson(*_); end

  def OGR_G_ExportToJsonEx(*_); end

  def OGR_G_ExportToKML(*_); end

  def OGR_G_ExportToWkb(*_); end

  def OGR_G_ExportToWkt(*_); end

  def OGR_G_FlattenTo2D(*_); end

  def OGR_G_ForceToLineString(*_); end

  def OGR_G_ForceToMultiLineString(*_); end

  def OGR_G_ForceToMultiPoint(*_); end

  def OGR_G_ForceToMultiPolygon(*_); end

  def OGR_G_ForceToPolygon(*_); end

  def OGR_G_GetCoordinateDimension(*_); end

  def OGR_G_GetDimension(*_); end

  def OGR_G_GetEnvelope(*_); end

  def OGR_G_GetEnvelope3D(*_); end

  def OGR_G_GetGeometryCount(*_); end

  def OGR_G_GetGeometryName(*_); end

  def OGR_G_GetGeometryRef(*_); end

  def OGR_G_GetGeometryType(*_); end

  def OGR_G_GetPoint(*_); end

  def OGR_G_GetPointCount(*_); end

  def OGR_G_GetPoints(*_); end

  def OGR_G_GetSpatialReference(*_); end

  def OGR_G_GetX(*_); end

  def OGR_G_GetY(*_); end

  def OGR_G_GetZ(*_); end

  def OGR_G_ImportFromWkb(*_); end

  def OGR_G_ImportFromWkt(*_); end

  def OGR_G_Intersection(*_); end

  def OGR_G_Intersects(*_); end

  def OGR_G_IsEmpty(*_); end

  def OGR_G_IsRing(*_); end

  def OGR_G_IsSimple(*_); end

  def OGR_G_IsValid(*_); end

  def OGR_G_Length(*_); end

  def OGR_G_Overlaps(*_); end

  def OGR_G_PointOnSurface(*_); end

  def OGR_G_Polygonize(*_); end

  def OGR_G_RemoveGeometry(*_); end

  def OGR_G_Segmentize(*_); end

  def OGR_G_SetCoordinateDimension(*_); end

  def OGR_G_SetPoint(*_); end

  def OGR_G_SetPointCount(*_); end

  def OGR_G_SetPoint_2D(*_); end

  def OGR_G_SetPoints(*_); end

  def OGR_G_Simplify(*_); end

  def OGR_G_SimplifyPreserveTopology(*_); end

  def OGR_G_SymDifference(*_); end

  def OGR_G_Touches(*_); end

  def OGR_G_Transform(*_); end

  def OGR_G_TransformTo(*_); end

  def OGR_G_Union(*_); end

  def OGR_G_UnionCascaded(*_); end

  def OGR_G_Within(*_); end

  def OGR_G_WkbSize(*_); end

  def OGR_GetFieldTypeName(*_); end

  def OGR_L_AlterFieldDefn(*_); end

  def OGR_L_Clip(*_); end

  def OGR_L_CommitTransaction(*_); end

  def OGR_L_CreateFeature(*_); end

  def OGR_L_CreateField(*_); end

  def OGR_L_CreateGeomField(*_); end

  def OGR_L_DeleteFeature(*_); end

  def OGR_L_DeleteField(*_); end

  def OGR_L_Dereference(*_); end

  def OGR_L_Erase(*_); end

  def OGR_L_FindFieldIndex(*_); end

  def OGR_L_GetExtent(*_); end

  def OGR_L_GetExtentEx(*_); end

  def OGR_L_GetFIDColumn(*_); end

  def OGR_L_GetFeature(*_); end

  def OGR_L_GetFeatureCount(*_); end

  def OGR_L_GetFeaturesRead(*_); end

  def OGR_L_GetGeomType(*_); end

  def OGR_L_GetGeometryColumn(*_); end

  def OGR_L_GetLayerDefn(*_); end

  def OGR_L_GetName(*_); end

  def OGR_L_GetNextFeature(*_); end

  def OGR_L_GetRefCount(*_); end

  def OGR_L_GetSpatialFilter(*_); end

  def OGR_L_GetSpatialRef(*_); end

  def OGR_L_GetStyleTable(*_); end

  def OGR_L_Identity(*_); end

  def OGR_L_Intersection(*_); end

  def OGR_L_Reference(*_); end

  def OGR_L_ReorderField(*_); end

  def OGR_L_ReorderFields(*_); end

  def OGR_L_ResetReading(*_); end

  def OGR_L_RollbackTransaction(*_); end

  def OGR_L_SetAttributeFilter(*_); end

  def OGR_L_SetFeature(*_); end

  def OGR_L_SetIgnoredFields(*_); end

  def OGR_L_SetNextByIndex(*_); end

  def OGR_L_SetSpatialFilter(*_); end

  def OGR_L_SetSpatialFilterEx(*_); end

  def OGR_L_SetSpatialFilterRect(*_); end

  def OGR_L_SetSpatialFilterRectEx(*_); end

  def OGR_L_SetStyleTable(*_); end

  def OGR_L_SetStyleTableDirectly(*_); end

  def OGR_L_StartTransaction(*_); end

  def OGR_L_SymDifference(*_); end

  def OGR_L_SyncToDisk(*_); end

  def OGR_L_TestCapability(*_); end

  def OGR_L_Union(*_); end

  def OGR_L_Update(*_); end

  def OGR_SM_AddPart(*_); end

  def OGR_SM_AddStyle(*_); end

  def OGR_SM_Create(*_); end

  def OGR_SM_Destroy(*_); end

  def OGR_SM_GetPart(*_); end

  def OGR_SM_GetPartCount(*_); end

  def OGR_SM_InitFromFeature(*_); end

  def OGR_SM_InitStyleString(*_); end

  def OGR_STBL_AddStyle(*_); end

  def OGR_STBL_Create(*_); end

  def OGR_STBL_Destroy(*_); end

  def OGR_STBL_Find(*_); end

  def OGR_STBL_GetLastStyleName(*_); end

  def OGR_STBL_GetNextStyle(*_); end

  def OGR_STBL_LoadStyleTable(*_); end

  def OGR_STBL_ResetStyleStringReading(*_); end

  def OGR_STBL_SaveStyleTable(*_); end

  def OGR_ST_Create(*_); end

  def OGR_ST_Destroy(*_); end

  def OGR_ST_GetParamDbl(*_); end

  def OGR_ST_GetParamNum(*_); end

  def OGR_ST_GetParamStr(*_); end

  def OGR_ST_GetRGBFromString(*_); end

  def OGR_ST_GetStyleString(*_); end

  def OGR_ST_GetType(*_); end

  def OGR_ST_GetUnit(*_); end

  def OGR_ST_SetParamDbl(*_); end

  def OGR_ST_SetParamNum(*_); end

  def OGR_ST_SetParamStr(*_); end

  def OGR_ST_SetUnit(*_); end
end

module FFI::OGR::API
  def self.OGRBuildPolygonFromEdges(*_); end

  def self.OGRCleanupAll(*_); end

  def self.OGRDeregisterDriver(*_); end

  def self.OGRGetDriver(*_); end

  def self.OGRGetDriverByName(*_); end

  def self.OGRGetDriverCount(*_); end

  def self.OGRGetOpenDS(*_); end

  def self.OGRGetOpenDSCount(*_); end

  def self.OGROpen(*_); end

  def self.OGROpenShared(*_); end

  def self.OGRRegisterAll(*_); end

  def self.OGRRegisterDriver(*_); end

  def self.OGRReleaseDataSource(*_); end

  def self.OGR_DS_CopyLayer(*_); end

  def self.OGR_DS_CreateLayer(*_); end

  def self.OGR_DS_DeleteLayer(*_); end

  def self.OGR_DS_Destroy(*_); end

  def self.OGR_DS_ExecuteSQL(*_); end

  def self.OGR_DS_GetDriver(*_); end

  def self.OGR_DS_GetLayer(*_); end

  def self.OGR_DS_GetLayerByName(*_); end

  def self.OGR_DS_GetLayerCount(*_); end

  def self.OGR_DS_GetName(*_); end

  def self.OGR_DS_GetStyleTable(*_); end

  def self.OGR_DS_ReleaseResultSet(*_); end

  def self.OGR_DS_SetStyleTable(*_); end

  def self.OGR_DS_SetStyleTableDirectly(*_); end

  def self.OGR_DS_SyncToDisk(*_); end

  def self.OGR_DS_TestCapability(*_); end

  def self.OGR_Dr_CopyDataSource(*_); end

  def self.OGR_Dr_CreateDataSource(*_); end

  def self.OGR_Dr_DeleteDataSource(*_); end

  def self.OGR_Dr_GetName(*_); end

  def self.OGR_Dr_Open(*_); end

  def self.OGR_Dr_TestCapability(*_); end

  def self.OGR_FD_AddFieldDefn(*_); end

  def self.OGR_FD_AddGeomFieldDefn(*_); end

  def self.OGR_FD_Create(*_); end

  def self.OGR_FD_DeleteFieldDefn(*_); end

  def self.OGR_FD_DeleteGeomFieldDefn(*_); end

  def self.OGR_FD_Dereference(*_); end

  def self.OGR_FD_Destroy(*_); end

  def self.OGR_FD_GetFieldCount(*_); end

  def self.OGR_FD_GetFieldDefn(*_); end

  def self.OGR_FD_GetFieldIndex(*_); end

  def self.OGR_FD_GetGeomFieldCount(*_); end

  def self.OGR_FD_GetGeomFieldDefn(*_); end

  def self.OGR_FD_GetGeomFieldIndex(*_); end

  def self.OGR_FD_GetGeomType(*_); end

  def self.OGR_FD_GetName(*_); end

  def self.OGR_FD_GetReferenceCount(*_); end

  def self.OGR_FD_IsGeometryIgnored(*_); end

  def self.OGR_FD_IsSame(*_); end

  def self.OGR_FD_IsStyleIgnored(*_); end

  def self.OGR_FD_Reference(*_); end

  def self.OGR_FD_Release(*_); end

  def self.OGR_FD_SetGeomType(*_); end

  def self.OGR_FD_SetGeometryIgnored(*_); end

  def self.OGR_FD_SetStyleIgnored(*_); end

  def self.OGR_F_Clone(*_); end

  def self.OGR_F_Create(*_); end

  def self.OGR_F_Destroy(*_); end

  def self.OGR_F_DumpReadable(*_); end

  def self.OGR_F_Equal(*_); end

  def self.OGR_F_GetDefnRef(*_); end

  def self.OGR_F_GetFID(*_); end

  def self.OGR_F_GetFieldAsBinary(*_); end

  def self.OGR_F_GetFieldAsDateTime(*_); end

  def self.OGR_F_GetFieldAsDouble(*_); end

  def self.OGR_F_GetFieldAsDoubleList(*_); end

  def self.OGR_F_GetFieldAsInteger(*_); end

  def self.OGR_F_GetFieldAsIntegerList(*_); end

  def self.OGR_F_GetFieldAsString(*_); end

  def self.OGR_F_GetFieldAsStringList(*_); end

  def self.OGR_F_GetFieldCount(*_); end

  def self.OGR_F_GetFieldDefnRef(*_); end

  def self.OGR_F_GetFieldIndex(*_); end

  def self.OGR_F_GetGeomFieldCount(*_); end

  def self.OGR_F_GetGeomFieldDefnRef(*_); end

  def self.OGR_F_GetGeomFieldIndex(*_); end

  def self.OGR_F_GetGeomFieldRef(*_); end

  def self.OGR_F_GetGeometryRef(*_); end

  def self.OGR_F_GetRawFieldRef(*_); end

  def self.OGR_F_GetStyleString(*_); end

  def self.OGR_F_GetStyleTable(*_); end

  def self.OGR_F_IsFieldSet(*_); end

  def self.OGR_F_SetFID(*_); end

  def self.OGR_F_SetFieldBinary(*_); end

  def self.OGR_F_SetFieldDateTime(*_); end

  def self.OGR_F_SetFieldDouble(*_); end

  def self.OGR_F_SetFieldDoubleList(*_); end

  def self.OGR_F_SetFieldInteger(*_); end

  def self.OGR_F_SetFieldIntegerList(*_); end

  def self.OGR_F_SetFieldRaw(*_); end

  def self.OGR_F_SetFieldString(*_); end

  def self.OGR_F_SetFieldStringList(*_); end

  def self.OGR_F_SetFrom(*_); end

  def self.OGR_F_SetFromWithMap(*_); end

  def self.OGR_F_SetGeomField(*_); end

  def self.OGR_F_SetGeomFieldDirectly(*_); end

  def self.OGR_F_SetGeometry(*_); end

  def self.OGR_F_SetGeometryDirectly(*_); end

  def self.OGR_F_SetStyleString(*_); end

  def self.OGR_F_SetStyleStringDirectly(*_); end

  def self.OGR_F_SetStyleTable(*_); end

  def self.OGR_F_SetStyleTableDirectly(*_); end

  def self.OGR_F_StealGeometry(*_); end

  def self.OGR_F_UnsetField(*_); end

  def self.OGR_Fld_Create(*_); end

  def self.OGR_Fld_Destroy(*_); end

  def self.OGR_Fld_GetJustify(*_); end

  def self.OGR_Fld_GetNameRef(*_); end

  def self.OGR_Fld_GetPrecision(*_); end

  def self.OGR_Fld_GetType(*_); end

  def self.OGR_Fld_GetWidth(*_); end

  def self.OGR_Fld_IsIgnored(*_); end

  def self.OGR_Fld_Set(*_); end

  def self.OGR_Fld_SetIgnored(*_); end

  def self.OGR_Fld_SetJustify(*_); end

  def self.OGR_Fld_SetName(*_); end

  def self.OGR_Fld_SetPrecision(*_); end

  def self.OGR_Fld_SetType(*_); end

  def self.OGR_Fld_SetWidth(*_); end

  def self.OGR_GFld_Create(*_); end

  def self.OGR_GFld_Destroy(*_); end

  def self.OGR_GFld_GetNameRef(*_); end

  def self.OGR_GFld_GetSpatialRef(*_); end

  def self.OGR_GFld_GetType(*_); end

  def self.OGR_GFld_IsIgnored(*_); end

  def self.OGR_GFld_SetIgnored(*_); end

  def self.OGR_GFld_SetName(*_); end

  def self.OGR_GFld_SetSpatialRef(*_); end

  def self.OGR_GFld_SetType(*_); end

  def self.OGR_G_AddGeometry(*_); end

  def self.OGR_G_AddGeometryDirectly(*_); end

  def self.OGR_G_AddPoint(*_); end

  def self.OGR_G_AddPoint_2D(*_); end

  def self.OGR_G_ApproximateArcAngles(*_); end

  def self.OGR_G_Area(*_); end

  def self.OGR_G_AssignSpatialReference(*_); end

  def self.OGR_G_Boundary(*_); end

  def self.OGR_G_Buffer(*_); end

  def self.OGR_G_Centroid(*_); end

  def self.OGR_G_Clone(*_); end

  def self.OGR_G_CloseRings(*_); end

  def self.OGR_G_Contains(*_); end

  def self.OGR_G_ConvexHull(*_); end

  def self.OGR_G_CreateFromFgf(*_); end

  def self.OGR_G_CreateFromGML(*_); end

  def self.OGR_G_CreateFromGMLTree(*_); end

  def self.OGR_G_CreateFromWkb(*_); end

  def self.OGR_G_CreateFromWkt(*_); end

  def self.OGR_G_CreateGeometry(*_); end

  def self.OGR_G_CreateGeometryFromJson(*_); end

  def self.OGR_G_Crosses(*_); end

  def self.OGR_G_DestroyGeometry(*_); end

  def self.OGR_G_Difference(*_); end

  def self.OGR_G_Disjoint(*_); end

  def self.OGR_G_Distance(*_); end

  def self.OGR_G_DumpReadable(*_); end

  def self.OGR_G_Empty(*_); end

  def self.OGR_G_Equals(*_); end

  def self.OGR_G_ExportEnvelopeToGMLTree(*_); end

  def self.OGR_G_ExportToGML(*_); end

  def self.OGR_G_ExportToGMLEx(*_); end

  def self.OGR_G_ExportToGMLTree(*_); end

  def self.OGR_G_ExportToJson(*_); end

  def self.OGR_G_ExportToJsonEx(*_); end

  def self.OGR_G_ExportToKML(*_); end

  def self.OGR_G_ExportToWkb(*_); end

  def self.OGR_G_ExportToWkt(*_); end

  def self.OGR_G_FlattenTo2D(*_); end

  def self.OGR_G_ForceToLineString(*_); end

  def self.OGR_G_ForceToMultiLineString(*_); end

  def self.OGR_G_ForceToMultiPoint(*_); end

  def self.OGR_G_ForceToMultiPolygon(*_); end

  def self.OGR_G_ForceToPolygon(*_); end

  def self.OGR_G_GetCoordinateDimension(*_); end

  def self.OGR_G_GetDimension(*_); end

  def self.OGR_G_GetEnvelope(*_); end

  def self.OGR_G_GetEnvelope3D(*_); end

  def self.OGR_G_GetGeometryCount(*_); end

  def self.OGR_G_GetGeometryName(*_); end

  def self.OGR_G_GetGeometryRef(*_); end

  def self.OGR_G_GetGeometryType(*_); end

  def self.OGR_G_GetPoint(*_); end

  def self.OGR_G_GetPointCount(*_); end

  def self.OGR_G_GetPoints(*_); end

  def self.OGR_G_GetSpatialReference(*_); end

  def self.OGR_G_GetX(*_); end

  def self.OGR_G_GetY(*_); end

  def self.OGR_G_GetZ(*_); end

  def self.OGR_G_ImportFromWkb(*_); end

  def self.OGR_G_ImportFromWkt(*_); end

  def self.OGR_G_Intersection(*_); end

  def self.OGR_G_Intersects(*_); end

  def self.OGR_G_IsEmpty(*_); end

  def self.OGR_G_IsRing(*_); end

  def self.OGR_G_IsSimple(*_); end

  def self.OGR_G_IsValid(*_); end

  def self.OGR_G_Length(*_); end

  def self.OGR_G_Overlaps(*_); end

  def self.OGR_G_PointOnSurface(*_); end

  def self.OGR_G_Polygonize(*_); end

  def self.OGR_G_RemoveGeometry(*_); end

  def self.OGR_G_Segmentize(*_); end

  def self.OGR_G_SetCoordinateDimension(*_); end

  def self.OGR_G_SetPoint(*_); end

  def self.OGR_G_SetPointCount(*_); end

  def self.OGR_G_SetPoint_2D(*_); end

  def self.OGR_G_SetPoints(*_); end

  def self.OGR_G_Simplify(*_); end

  def self.OGR_G_SimplifyPreserveTopology(*_); end

  def self.OGR_G_SymDifference(*_); end

  def self.OGR_G_Touches(*_); end

  def self.OGR_G_Transform(*_); end

  def self.OGR_G_TransformTo(*_); end

  def self.OGR_G_Union(*_); end

  def self.OGR_G_UnionCascaded(*_); end

  def self.OGR_G_Within(*_); end

  def self.OGR_G_WkbSize(*_); end

  def self.OGR_GetFieldTypeName(*_); end

  def self.OGR_L_AlterFieldDefn(*_); end

  def self.OGR_L_Clip(*_); end

  def self.OGR_L_CommitTransaction(*_); end

  def self.OGR_L_CreateFeature(*_); end

  def self.OGR_L_CreateField(*_); end

  def self.OGR_L_CreateGeomField(*_); end

  def self.OGR_L_DeleteFeature(*_); end

  def self.OGR_L_DeleteField(*_); end

  def self.OGR_L_Dereference(*_); end

  def self.OGR_L_Erase(*_); end

  def self.OGR_L_FindFieldIndex(*_); end

  def self.OGR_L_GetExtent(*_); end

  def self.OGR_L_GetExtentEx(*_); end

  def self.OGR_L_GetFIDColumn(*_); end

  def self.OGR_L_GetFeature(*_); end

  def self.OGR_L_GetFeatureCount(*_); end

  def self.OGR_L_GetFeaturesRead(*_); end

  def self.OGR_L_GetGeomType(*_); end

  def self.OGR_L_GetGeometryColumn(*_); end

  def self.OGR_L_GetLayerDefn(*_); end

  def self.OGR_L_GetName(*_); end

  def self.OGR_L_GetNextFeature(*_); end

  def self.OGR_L_GetRefCount(*_); end

  def self.OGR_L_GetSpatialFilter(*_); end

  def self.OGR_L_GetSpatialRef(*_); end

  def self.OGR_L_GetStyleTable(*_); end

  def self.OGR_L_Identity(*_); end

  def self.OGR_L_Intersection(*_); end

  def self.OGR_L_Reference(*_); end

  def self.OGR_L_ReorderField(*_); end

  def self.OGR_L_ReorderFields(*_); end

  def self.OGR_L_ResetReading(*_); end

  def self.OGR_L_RollbackTransaction(*_); end

  def self.OGR_L_SetAttributeFilter(*_); end

  def self.OGR_L_SetFeature(*_); end

  def self.OGR_L_SetIgnoredFields(*_); end

  def self.OGR_L_SetNextByIndex(*_); end

  def self.OGR_L_SetSpatialFilter(*_); end

  def self.OGR_L_SetSpatialFilterEx(*_); end

  def self.OGR_L_SetSpatialFilterRect(*_); end

  def self.OGR_L_SetSpatialFilterRectEx(*_); end

  def self.OGR_L_SetStyleTable(*_); end

  def self.OGR_L_SetStyleTableDirectly(*_); end

  def self.OGR_L_StartTransaction(*_); end

  def self.OGR_L_SymDifference(*_); end

  def self.OGR_L_SyncToDisk(*_); end

  def self.OGR_L_TestCapability(*_); end

  def self.OGR_L_Union(*_); end

  def self.OGR_L_Update(*_); end

  def self.OGR_SM_AddPart(*_); end

  def self.OGR_SM_AddStyle(*_); end

  def self.OGR_SM_Create(*_); end

  def self.OGR_SM_Destroy(*_); end

  def self.OGR_SM_GetPart(*_); end

  def self.OGR_SM_GetPartCount(*_); end

  def self.OGR_SM_InitFromFeature(*_); end

  def self.OGR_SM_InitStyleString(*_); end

  def self.OGR_STBL_AddStyle(*_); end

  def self.OGR_STBL_Create(*_); end

  def self.OGR_STBL_Destroy(*_); end

  def self.OGR_STBL_Find(*_); end

  def self.OGR_STBL_GetLastStyleName(*_); end

  def self.OGR_STBL_GetNextStyle(*_); end

  def self.OGR_STBL_LoadStyleTable(*_); end

  def self.OGR_STBL_ResetStyleStringReading(*_); end

  def self.OGR_STBL_SaveStyleTable(*_); end

  def self.OGR_ST_Create(*_); end

  def self.OGR_ST_Destroy(*_); end

  def self.OGR_ST_GetParamDbl(*_); end

  def self.OGR_ST_GetParamNum(*_); end

  def self.OGR_ST_GetParamStr(*_); end

  def self.OGR_ST_GetRGBFromString(*_); end

  def self.OGR_ST_GetStyleString(*_); end

  def self.OGR_ST_GetType(*_); end

  def self.OGR_ST_GetUnit(*_); end

  def self.OGR_ST_SetParamDbl(*_); end

  def self.OGR_ST_SetParamNum(*_); end

  def self.OGR_ST_SetParamStr(*_); end

  def self.OGR_ST_SetUnit(*_); end
end

class FFI::OGR::ContourWriterInfo
end

module FFI::OGR::Core
  def OGRCalloc(*_); end

  def OGRFree(*_); end

  def OGRGeometryTypeToName(*_); end

  def OGRMalloc(*_); end

  def OGRMergeGeometryTypes(*_); end

  def OGRParseDate(*_); end

  def OGRRealloc(*_); end
end

module FFI::OGR::Core
  def self.OGRCalloc(*_); end

  def self.OGRFree(*_); end

  def self.OGRGeometryTypeToName(*_); end

  def self.OGRMalloc(*_); end

  def self.OGRMergeGeometryTypes(*_); end

  def self.OGRParseDate(*_); end

  def self.OGRRealloc(*_); end
end

class FFI::OGR::Envelope
end

class FFI::OGR::Envelope3D
end

class FFI::OGR::Field
end

class FFI::OGR::FieldTypes::Binary
end

class FFI::OGR::FieldTypes::Date
end

class FFI::OGR::FieldTypes::Integer64List
end

class FFI::OGR::FieldTypes::IntegerList
end

class FFI::OGR::FieldTypes::RealList
end

class FFI::OGR::FieldTypes::Set
end

class FFI::OGR::FieldTypes::StringList
end

module FFI::OGR::Geocoding
  def OGRGeocode(*_); end

  def OGRGeocodeCreateSession(*_); end

  def OGRGeocodeDestroySession(*_); end

  def OGRGeocodeFreeResult(*_); end

  def OGRGeocodeReverse(*_); end
end

module FFI::OGR::Geocoding
  def self.OGRGeocode(*_); end

  def self.OGRGeocodeCreateSession(*_); end

  def self.OGRGeocodeDestroySession(*_); end

  def self.OGRGeocodeFreeResult(*_); end

  def self.OGRGeocodeReverse(*_); end
end

module FFI::OGR::SRSAPI
  def OCTDestroyCoordinateTransformation(*_); end

  def OCTNewCoordinateTransformation(*_); end

  def OCTTransform(*_); end

  def OCTTransformEx(*_); end

  def OSRAutoIdentifyEPSG(*_); end

  def OSRAxisEnumToName(*_); end

  def OSRCleanup(*_); end

  def OSRClone(*_); end

  def OSRCloneGeogCS(*_); end

  def OSRCopyGeogCSFrom(*_); end

  def OSRDereference(*_); end

  def OSRDestroySpatialReference(*_); end

  def OSREPSGTreatsAsLatLong(*_); end

  def OSREPSGTreatsAsNorthingEasting(*_); end

  def OSRExportToERM(*_); end

  def OSRExportToMICoordSys(*_); end

  def OSRExportToPCI(*_); end

  def OSRExportToPrettyWkt(*_); end

  def OSRExportToProj4(*_); end

  def OSRExportToUSGS(*_); end

  def OSRExportToWkt(*_); end

  def OSRExportToXML(*_); end

  def OSRGetAngularUnits(*_); end

  def OSRGetAttrValue(*_); end

  def OSRGetAuthorityCode(*_); end

  def OSRGetAuthorityName(*_); end

  def OSRGetAxis(*_); end

  def OSRGetInvFlattening(*_); end

  def OSRGetLinearUnits(*_); end

  def OSRGetNormProjParm(*_); end

  def OSRGetPrimeMeridian(*_); end

  def OSRGetProjParm(*_); end

  def OSRGetSemiMajor(*_); end

  def OSRGetSemiMinor(*_); end

  def OSRGetTOWGS84(*_); end

  def OSRGetTargetLinearUnits(*_); end

  def OSRGetUTMZone(*_); end

  def OSRImportFromEPSG(*_); end

  def OSRImportFromEPSGA(*_); end

  def OSRImportFromERM(*_); end

  def OSRImportFromESRI(*_); end

  def OSRImportFromMICoordSys(*_); end

  def OSRImportFromPCI(*_); end

  def OSRImportFromProj4(*_); end

  def OSRImportFromUSGS(*_); end

  def OSRImportFromUrl(*_); end

  def OSRImportFromWkt(*_); end

  def OSRImportFromXML(*_); end

  def OSRIsCompound(*_); end

  def OSRIsGeocentric(*_); end

  def OSRIsGeographic(*_); end

  def OSRIsLocal(*_); end

  def OSRIsProjected(*_); end

  def OSRIsSame(*_); end

  def OSRIsSameGeogCS(*_); end

  def OSRIsSameVertCS(*_); end

  def OSRIsVertical(*_); end

  def OSRMorphFromESRI(*_); end

  def OSRMorphToESRI(*_); end

  def OSRNewSpatialReference(*_); end

  def OSRReference(*_); end

  def OSRRelease(*_); end

  def OSRSetACEA(*_); end

  def OSRSetAE(*_); end

  def OSRSetAngularUnits(*_); end

  def OSRSetAttrValue(*_); end

  def OSRSetAuthority(*_); end

  def OSRSetBonne(*_); end

  def OSRSetCEA(*_); end

  def OSRSetCS(*_); end

  def OSRSetCompoundCS(*_); end

  def OSRSetEC(*_); end

  def OSRSetEckert(*_); end

  def OSRSetEckertIV(*_); end

  def OSRSetEckertVI(*_); end

  def OSRSetEquirectangular(*_); end

  def OSRSetEquirectangular2(*_); end

  def OSRSetFromUserInput(*_); end

  def OSRSetGEOS(*_); end

  def OSRSetGH(*_); end

  def OSRSetGS(*_); end

  def OSRSetGaussSchreiberTMercator(*_); end

  def OSRSetGeocCS(*_); end

  def OSRSetGeogCS(*_); end

  def OSRSetGnomonic(*_); end

  def OSRSetHOM(*_); end

  def OSRSetHOM2PNO(*_); end

  def OSRSetIGH(*_); end

  def OSRSetIWMPolyconic(*_); end

  def OSRSetKrovak(*_); end

  def OSRSetLAEA(*_); end

  def OSRSetLCC(*_); end

  def OSRSetLCC1SP(*_); end

  def OSRSetLCCB(*_); end

  def OSRSetLinearUnits(*_); end

  def OSRSetLinearUnitsAndUpdateParameters(*_); end

  def OSRSetLocalCS(*_); end

  def OSRSetMC(*_); end

  def OSRSetMercator(*_); end

  def OSRSetMollweide(*_); end

  def OSRSetNZMG(*_); end

  def OSRSetNormProjParm(*_); end

  def OSRSetOS(*_); end

  def OSRSetOrthographic(*_); end

  def OSRSetPS(*_); end

  def OSRSetPolyconic(*_); end

  def OSRSetProjCS(*_); end

  def OSRSetProjParm(*_); end

  def OSRSetProjection(*_); end

  def OSRSetRobinson(*_); end

  def OSRSetSOC(*_); end

  def OSRSetSinusoidal(*_); end

  def OSRSetStatePlane(*_); end

  def OSRSetStatePlaneWithUnits(*_); end

  def OSRSetStereographic(*_); end

  def OSRSetTM(*_); end

  def OSRSetTMG(*_); end

  def OSRSetTMSO(*_); end

  def OSRSetTMVariant(*_); end

  def OSRSetTOWGS84(*_); end

  def OSRSetTargetLinearUnits(*_); end

  def OSRSetUTM(*_); end

  def OSRSetVDG(*_); end

  def OSRSetVertCS(*_); end

  def OSRSetWagner(*_); end

  def OSRSetWellKnownGeogCS(*_); end

  def OSRValidate(*_); end
end

module FFI::OGR::SRSAPI
  def self.OCTDestroyCoordinateTransformation(*_); end

  def self.OCTNewCoordinateTransformation(*_); end

  def self.OCTTransform(*_); end

  def self.OCTTransformEx(*_); end

  def self.OSRAutoIdentifyEPSG(*_); end

  def self.OSRAxisEnumToName(*_); end

  def self.OSRCleanup(*_); end

  def self.OSRClone(*_); end

  def self.OSRCloneGeogCS(*_); end

  def self.OSRCopyGeogCSFrom(*_); end

  def self.OSRDereference(*_); end

  def self.OSRDestroySpatialReference(*_); end

  def self.OSREPSGTreatsAsLatLong(*_); end

  def self.OSREPSGTreatsAsNorthingEasting(*_); end

  def self.OSRExportToERM(*_); end

  def self.OSRExportToMICoordSys(*_); end

  def self.OSRExportToPCI(*_); end

  def self.OSRExportToPrettyWkt(*_); end

  def self.OSRExportToProj4(*_); end

  def self.OSRExportToUSGS(*_); end

  def self.OSRExportToWkt(*_); end

  def self.OSRExportToXML(*_); end

  def self.OSRGetAngularUnits(*_); end

  def self.OSRGetAttrValue(*_); end

  def self.OSRGetAuthorityCode(*_); end

  def self.OSRGetAuthorityName(*_); end

  def self.OSRGetAxis(*_); end

  def self.OSRGetInvFlattening(*_); end

  def self.OSRGetLinearUnits(*_); end

  def self.OSRGetNormProjParm(*_); end

  def self.OSRGetPrimeMeridian(*_); end

  def self.OSRGetProjParm(*_); end

  def self.OSRGetSemiMajor(*_); end

  def self.OSRGetSemiMinor(*_); end

  def self.OSRGetTOWGS84(*_); end

  def self.OSRGetTargetLinearUnits(*_); end

  def self.OSRGetUTMZone(*_); end

  def self.OSRImportFromEPSG(*_); end

  def self.OSRImportFromEPSGA(*_); end

  def self.OSRImportFromERM(*_); end

  def self.OSRImportFromESRI(*_); end

  def self.OSRImportFromMICoordSys(*_); end

  def self.OSRImportFromPCI(*_); end

  def self.OSRImportFromProj4(*_); end

  def self.OSRImportFromUSGS(*_); end

  def self.OSRImportFromUrl(*_); end

  def self.OSRImportFromWkt(*_); end

  def self.OSRImportFromXML(*_); end

  def self.OSRIsCompound(*_); end

  def self.OSRIsGeocentric(*_); end

  def self.OSRIsGeographic(*_); end

  def self.OSRIsLocal(*_); end

  def self.OSRIsProjected(*_); end

  def self.OSRIsSame(*_); end

  def self.OSRIsSameGeogCS(*_); end

  def self.OSRIsSameVertCS(*_); end

  def self.OSRIsVertical(*_); end

  def self.OSRMorphFromESRI(*_); end

  def self.OSRMorphToESRI(*_); end

  def self.OSRNewSpatialReference(*_); end

  def self.OSRReference(*_); end

  def self.OSRRelease(*_); end

  def self.OSRSetACEA(*_); end

  def self.OSRSetAE(*_); end

  def self.OSRSetAngularUnits(*_); end

  def self.OSRSetAttrValue(*_); end

  def self.OSRSetAuthority(*_); end

  def self.OSRSetBonne(*_); end

  def self.OSRSetCEA(*_); end

  def self.OSRSetCS(*_); end

  def self.OSRSetCompoundCS(*_); end

  def self.OSRSetEC(*_); end

  def self.OSRSetEckert(*_); end

  def self.OSRSetEckertIV(*_); end

  def self.OSRSetEckertVI(*_); end

  def self.OSRSetEquirectangular(*_); end

  def self.OSRSetEquirectangular2(*_); end

  def self.OSRSetFromUserInput(*_); end

  def self.OSRSetGEOS(*_); end

  def self.OSRSetGH(*_); end

  def self.OSRSetGS(*_); end

  def self.OSRSetGaussSchreiberTMercator(*_); end

  def self.OSRSetGeocCS(*_); end

  def self.OSRSetGeogCS(*_); end

  def self.OSRSetGnomonic(*_); end

  def self.OSRSetHOM(*_); end

  def self.OSRSetHOM2PNO(*_); end

  def self.OSRSetIGH(*_); end

  def self.OSRSetIWMPolyconic(*_); end

  def self.OSRSetKrovak(*_); end

  def self.OSRSetLAEA(*_); end

  def self.OSRSetLCC(*_); end

  def self.OSRSetLCC1SP(*_); end

  def self.OSRSetLCCB(*_); end

  def self.OSRSetLinearUnits(*_); end

  def self.OSRSetLinearUnitsAndUpdateParameters(*_); end

  def self.OSRSetLocalCS(*_); end

  def self.OSRSetMC(*_); end

  def self.OSRSetMercator(*_); end

  def self.OSRSetMollweide(*_); end

  def self.OSRSetNZMG(*_); end

  def self.OSRSetNormProjParm(*_); end

  def self.OSRSetOS(*_); end

  def self.OSRSetOrthographic(*_); end

  def self.OSRSetPS(*_); end

  def self.OSRSetPolyconic(*_); end

  def self.OSRSetProjCS(*_); end

  def self.OSRSetProjParm(*_); end

  def self.OSRSetProjection(*_); end

  def self.OSRSetRobinson(*_); end

  def self.OSRSetSOC(*_); end

  def self.OSRSetSinusoidal(*_); end

  def self.OSRSetStatePlane(*_); end

  def self.OSRSetStatePlaneWithUnits(*_); end

  def self.OSRSetStereographic(*_); end

  def self.OSRSetTM(*_); end

  def self.OSRSetTMG(*_); end

  def self.OSRSetTMSO(*_); end

  def self.OSRSetTMVariant(*_); end

  def self.OSRSetTOWGS84(*_); end

  def self.OSRSetTargetLinearUnits(*_); end

  def self.OSRSetUTM(*_); end

  def self.OSRSetVDG(*_); end

  def self.OSRSetVertCS(*_); end

  def self.OSRSetWagner(*_); end

  def self.OSRSetWellKnownGeogCS(*_); end

  def self.OSRValidate(*_); end
end

class FFI::OGR::StyleParam
end

class FFI::OGR::StyleValue
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

module FFI::Platform
  def self.bsd?(); end

  def self.is_os(os); end

  def self.mac?(); end

  def self.solaris?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class FFI::PlatformError
end

class FFI::PlatformError
end

class FFI::Pointer
  def +(_); end

  def address(); end

  def autorelease=(autorelease); end

  def autorelease?(); end

  def free(); end

  def initialize(*_); end

  def null?(); end

  def order(*_); end

  def read(type); end

  def read_array_of_type(type, reader, length); end

  def read_string(len=T.unsafe(nil)); end

  def read_string_length(len); end

  def read_string_to_null(); end

  def slice(_, _1); end

  def to_i(); end

  def to_ptr(); end

  def write(type, value); end

  def write_array_of_type(type, writer, ary); end

  def write_string(str, len=T.unsafe(nil)); end

  def write_string_length(str, len); end
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  def self.size(); end
end

class FFI::StrPtrConverter
end

class FFI::StrPtrConverter
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end
end

class FFI::Struct
  def [](_); end

  def []=(_, _1); end

  def align(); end

  def alignment(); end

  def clear(); end

  def initialize(*_); end

  def layout(); end

  def members(); end

  def null?(); end

  def offset_of(name); end

  def offsets(); end

  def order(*_); end

  def pointer(); end

  def size(); end

  def to_ptr(); end

  def values(); end
end

class FFI::Struct::InlineArray
  include ::Enumerable
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def initialize(_, _1); end

  def size(); end

  def to_a(); end

  def to_ptr(); end
end

class FFI::Struct::InlineArray
end

class FFI::Struct::ManagedStructConverter
  def from_native(ptr, ctx); end
end

class FFI::Struct::ManagedStructConverter
end

class FFI::Struct
  def self.align(alignment=T.unsafe(nil)); end

  def self.aligned(alignment=T.unsafe(nil)); end

  def self.alignment(); end

  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.auto_ptr(); end

  def self.by_ref(flags=T.unsafe(nil)); end

  def self.by_value(); end

  def self.callback(params, ret); end

  def self.enclosing_module(); end

  def self.find_field_type(type, mod=T.unsafe(nil)); end

  def self.find_type(type, mod=T.unsafe(nil)); end

  def self.in(); end

  def self.layout(*spec); end

  def self.members(); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end

  def self.offset_of(name); end

  def self.offsets(); end

  def self.out(); end

  def self.pack(packed=T.unsafe(nil)); end

  def self.packed(packed=T.unsafe(nil)); end

  def self.ptr(flags=T.unsafe(nil)); end

  def self.size(); end

  def self.size=(size); end

  def self.val(); end
end

class FFI::StructByReference
  include ::FFI::DataConverter
  def initialize(struct_class); end

  def native_type(); end

  def struct_class(); end
end

class FFI::StructByReference
end

class FFI::StructByValue
  def layout(); end

  def struct_class(); end
end

class FFI::StructByValue
end

class FFI::StructLayout
  def [](_); end

  def __union!(); end

  def fields(); end

  def initialize(_, _1, _2); end

  def members(); end

  def offset_of(field_name); end

  def offsets(); end

  def to_a(); end
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::CharArray
  def to_str(); end
end

class FFI::StructLayout::CharArray
end

class FFI::StructLayout::Enum
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::Enum
end

class FFI::StructLayout::Field
  def alignment(); end

  def get(_); end

  def initialize(*_); end

  def name(); end

  def offset(); end

  def put(_, _1); end

  def size(); end

  def type(); end
end

class FFI::StructLayout::Field
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::InnerStruct
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::InnerStruct
end

class FFI::StructLayout::Mapped
  def get(ptr); end

  def initialize(name, offset, type, orig_field); end

  def put(ptr, value); end
end

class FFI::StructLayout::Mapped
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayout
end

class FFI::StructLayoutBuilder
  def add(name, type, offset=T.unsafe(nil)); end

  def add_array(name, type, count, offset=T.unsafe(nil)); end

  def add_field(name, type, offset=T.unsafe(nil)); end

  def add_struct(name, type, offset=T.unsafe(nil)); end

  def alignment(); end

  def alignment=(align); end

  def build(); end

  def packed=(packed); end

  def size(); end

  def size=(size); end

  def union=(is_union); end

  def union?(); end
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::StructLayoutBuilder
end

class FFI::Type
  def alignment(); end

  def initialize(_); end

  def size(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

class FFI::Type::Builtin
end

class FFI::Type::Builtin
end

FFI::Type::Function = FFI::FunctionType

class FFI::Type::Mapped
  def from_native(*_); end

  def native_type(); end

  def to_native(*_); end

  def type(); end
end

class FFI::Type::Mapped
end

FFI::Type::Struct = FFI::StructByValue

class FFI::Type
end

class FFI::Union
end

class FFI::Union
  def self.builder(); end
end

class FFI::VariadicInvoker
  def attach(mod, mname); end

  def call(*args, &block); end

  def init(arg_types, type_map); end

  def initialize(_, _1, _2, _3); end

  def invoke(_, _1); end
end

class FFI::VariadicInvoker
end

module FFI
  def self.add_typedef(old, add); end

  def self.errno(); end

  def self.errno=(error); end

  def self.find_type(name, type_map=T.unsafe(nil)); end

  def self.map_library_name(lib); end

  def self.type_size(type); end

  def self.typedef(old, add); end
end

module FFTW
end

module FFTW
  def self.convol(a1, a2); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class File
  def self.exists?(_); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, **options, &block); end

  def safe_ln(*args, **options); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

class GDAL::Grid
  def algorithm_options(*args, &block); end

  def algorithm_type(*args, &block); end
end

module GDAL::Logger
  include ::LogSwitch
  include ::LogSwitch::InstanceMethods
end

module GDAL::Logger
  extend ::LogSwitch::ClassMethods
  def self.included(b); end
end

class GDAL::RPCInfo
  def [](*args, &block); end
end

module GDAL
  extend ::GDAL::InternalHelpers::ClassMethods
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
end

class Hash
  def self.try_convert(_); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect_last_value(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::Notifier::AbstractNotifier
  def initialize(prefix, base_notifier); end
end

class IRB::Notifier::LeveledNotifier
  def initialize(base, level, prefix); end
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def byebug(); end

  def debugger(); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def remote_byebug(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module LogSwitch
  VERSION = ::T.let(nil, ::T.untyped)
end

module LogSwitch::ClassMethods
  def before_log(); end

  def before_log=(block); end

  def default_log_level(); end

  def default_log_level=(level); end

  def log_class_name(); end

  def log_class_name=(value); end

  def log_class_name?(); end

  def logger(); end

  def logger=(new_logger); end

  def logging_enabled(); end

  def logging_enabled=(value); end

  def logging_enabled?(); end
end

module LogSwitch::ClassMethods
end

module LogSwitch::InstanceMethods
  def log(message, level=T.unsafe(nil)); end

  def logger(); end
end

module LogSwitch::InstanceMethods
end

module LogSwitch
  def self.included(base); end

  def self.logger=(new_logger); end

  def self.reset_config!(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

class Module
  def rake_extension(method); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class MultiXml::DisallowedTypeError
  def initialize(type); end
end

class MultiXml::DisallowedTypeError
end

class MultiXml::NoParserError
end

class MultiXml::NoParserError
end

class MultiXml::ParseError
end

class MultiXml::ParseError
end

module MultiXml
  def self.default_parser(); end

  def self.parse(xml, options=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(new_parser); end
end

class NArray
  def %(_); end

  def &(_); end

  def *(_); end

  def **(_); end

  def +(_); end

  def -(_); end

  def -@(); end

  def /(_); end

  def <(_); end

  def <=(_); end

  def ==(other); end

  def >(_); end

  def >=(_); end

  def [](*_); end

  def []=(*_); end

  def ^(_); end

  def abs(); end

  def accum(*_); end

  def add!(_); end

  def all?(); end

  def and(_); end

  def angle(); end

  def any?(); end

  def arg(); end

  def ceil(); end

  def clone(); end

  def coerce(_); end

  def collect(); end

  def collect!(); end

  def complex?(); end

  def conj(); end

  def conj!(); end

  def conjugate(); end

  def conjugate!(); end

  def count_false(); end

  def count_true(); end

  def cumprod(); end

  def cumprod!(); end

  def cumsum(); end

  def cumsum!(); end

  def delete_at(*args); end

  def dim(); end

  def dimension(); end

  def div!(_); end

  def each(&blk); end

  def element_size(); end

  def empty?(); end

  def eq(_); end

  def eql?(other); end

  def fill(_); end

  def fill!(_); end

  def flatten(); end

  def flatten!(); end

  def floor(); end

  def ge(_); end

  def gt(_); end

  def hton(); end

  def htov(); end

  def im(); end

  def imag(); end

  def imag=(imag); end

  def image(); end

  def indgen(*_); end

  def indgen!(*_); end

  def integer?(); end

  def le(_); end

  def length(); end

  def lt(_); end

  def map(); end

  def map!(); end

  def mask(_); end

  def max(*_); end

  def mean(*ranks); end

  def median(rank=T.unsafe(nil)); end

  def min(*_); end

  def mod(_); end

  def mod!(_); end

  def mul!(_); end

  def mul_accum(*_); end

  def mul_add(*_); end

  def ne(_); end

  def newdim(*_); end

  def newdim!(*_); end

  def newdim=(*newdim); end

  def newrank(*_); end

  def newrank!(*_); end

  def newrank=(*newrank); end

  def none?(); end

  def not(); end

  def ntoh(); end

  def or(_); end

  def original(); end

  def prod(*_); end

  def random(*_); end

  def random!(*_); end

  def randomn(); end

  def randomn!(); end

  def rank(); end

  def rank_total(*ranks); end

  def real(); end

  def recip(); end

  def refer(); end

  def reshape(*_); end

  def reshape!(*_); end

  def reverse(*ranks); end

  def rms(*ranks); end

  def rmsdev(*ranks); end

  def rot90(n_times=T.unsafe(nil)); end

  def round(); end

  def sbt!(_); end

  def shape(); end

  def shape=(*shape); end

  def size(); end

  def sizes(); end

  def slice(*_); end

  def sort(*_); end

  def sort!(*_); end

  def sort_index(*_); end

  def stddev(*ranks); end

  def sum(*_); end

  def swap_byte(); end

  def to_a(); end

  def to_binary(); end

  def to_f(); end

  def to_i(); end

  def to_string(); end

  def to_type(_); end

  def to_type_as_binary(_); end

  def total(); end

  def transpose(*_); end

  def typecode(); end

  def vtoh(); end

  def where(); end

  def where2(); end

  def xor(_); end

  def |(_); end

  def ~(); end
  BYTE = ::T.let(nil, ::T.untyped)
  CLASS_DIMENSION = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DCOMPLEX = ::T.let(nil, ::T.untyped)
  DFLOAT = ::T.let(nil, ::T.untyped)
  ENDIAN = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  LINT = ::T.let(nil, ::T.untyped)
  NARRAY_VERSION = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  ROBJ = ::T.let(nil, ::T.untyped)
  SCOMPLEX = ::T.let(nil, ::T.untyped)
  SFLOAT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
end

class NArray
  def self.[](*_); end

  def self.byte(*_); end

  def self.cast(array, type=T.unsafe(nil)); end

  def self.complex(*_); end

  def self.dcomplex(*_); end

  def self.dfloat(*_); end

  def self.div(_, _1); end

  def self.float(*_); end

  def self.int(*_); end

  def self.lint(*_); end

  def self.mul(_, _1); end

  def self.mul_add(*_); end

  def self.object(*_); end

  def self.ref(_); end

  def self.refer(_); end

  def self.scomplex(*_); end

  def self.sfloat(*_); end

  def self.sint(*_); end

  def self.to_na(*_); end

  def self.to_narray(*_); end
end

class NArrayScalar
end

class NArrayScalar
end

module NMath
  E = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
end

module NMath
  def self.acos(_); end

  def self.acosh(_); end

  def self.acot(x); end

  def self.acoth(x); end

  def self.acsc(x); end

  def self.acsch(x); end

  def self.asec(x); end

  def self.asech(x); end

  def self.asin(_); end

  def self.asinh(_); end

  def self.atan(_); end

  def self.atan2(_, _1); end

  def self.atanh(_); end

  def self.cos(_); end

  def self.cosh(_); end

  def self.cot(x); end

  def self.coth(x); end

  def self.covariance(x, y, *ranks); end

  def self.csc(x); end

  def self.csch(x); end

  def self.exp(_); end

  def self.log(_); end

  def self.log10(_); end

  def self.log2(_); end

  def self.recip(x); end

  def self.sec(x); end

  def self.sech(x); end

  def self.sin(_); end

  def self.sinh(_); end

  def self.sqrt(_); end

  def self.tan(_); end

  def self.tanh(_); end
end

class NMatrix
  def *(other); end

  def **(n); end

  def +(other); end

  def -(other); end

  def /(other); end

  def I(); end

  def coerce_rev(other, id); end

  def diagonal(val); end

  def diagonal!(val=T.unsafe(nil)); end

  def identity(); end

  def inverse(); end

  def lu(); end

  def lu!(); end

  def lu_fact(); end

  def lu_fact!(); end

  def transpose(*arg); end

  def unit(); end
  CLASS_DIMENSION = ::T.let(nil, ::T.untyped)
end

class NMatrix
end

class NMatrixLU
  def initialize(_, _1); end

  def solve(_); end
end

class NMatrixLU
end

class NVector
  def *(other); end

  def **(n); end

  def +(other); end

  def -(other); end

  def /(other); end

  def coerce_rev(other, id); end
  CLASS_DIMENSION = ::T.let(nil, ::T.untyped)
end

class NVector
end

class NameError
  include ::DidYouMean::Correctable
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end
end

class OGR::GeometryCollection
  include ::OGR::GeometryMixins::Extensions
end

class OGR::GeometryCollection
  extend ::OGR::Geometry::ClassMethods
end

class OGR::Layer
  ALTER_ALL_FLAG = ::T.let(nil, ::T.untyped)
  ALTER_NAME_FLAG = ::T.let(nil, ::T.untyped)
  ALTER_TYPE_FLAG = ::T.let(nil, ::T.untyped)
  ALTER_WIDTH_PRECISION_FLAG = ::T.let(nil, ::T.untyped)
end

class OGR::LineString
  include ::OGR::GeometryMixins::Extensions
end

class OGR::LineString
  extend ::OGR::Geometry::ClassMethods
end

class OGR::MultiLineString
  include ::OGR::GeometryMixins::Extensions
end

class OGR::MultiLineString
  extend ::OGR::Geometry::ClassMethods
end

class OGR::MultiPoint
  include ::OGR::GeometryMixins::Extensions
end

class OGR::MultiPoint
  extend ::OGR::Geometry::ClassMethods
end

class OGR::MultiPolygon
  include ::OGR::GeometryMixins::Extensions
end

class OGR::MultiPolygon
  extend ::OGR::Geometry::ClassMethods
end

class OGR::NoneGeometry
  include ::OGR::GeometryMixins::Extensions
end

class OGR::NoneGeometry
  extend ::OGR::Geometry::ClassMethods
end

class OGR::Point
  include ::OGR::GeometryMixins::Extensions
end

class OGR::Point
  extend ::OGR::Geometry::ClassMethods
end

class OGR::Polygon
  include ::OGR::GeometryMixins::Extensions
end

class OGR::Polygon
  extend ::OGR::Geometry::ClassMethods
end

class OGR::SpatialReference
  CENTIMETER_LABEL = ::T.let(nil, ::T.untyped)
  CHAIN_LABEL = ::T.let(nil, ::T.untyped)
  DECIMETER_LABEL = ::T.let(nil, ::T.untyped)
  DEGREE_LABEL = ::T.let(nil, ::T.untyped)
  FOOT_LABEL = ::T.let(nil, ::T.untyped)
  INDIAN_CHAIN_LABEL = ::T.let(nil, ::T.untyped)
  INDIAN_FOOT_LABEL = ::T.let(nil, ::T.untyped)
  INDIAN_YARD_LABEL = ::T.let(nil, ::T.untyped)
  INTL_CHAIN_LABEL = ::T.let(nil, ::T.untyped)
  INTL_FATHOM_LABEL = ::T.let(nil, ::T.untyped)
  INTL_FOOT_LABEL = ::T.let(nil, ::T.untyped)
  INTL_INCH_LABEL = ::T.let(nil, ::T.untyped)
  INTL_LINK_LABEL = ::T.let(nil, ::T.untyped)
  INTL_NAUTICAL_MILE_LABEL = ::T.let(nil, ::T.untyped)
  INTL_STATUTE_MILE_LABEL = ::T.let(nil, ::T.untyped)
  INTL_YARD_LABEL = ::T.let(nil, ::T.untyped)
  KILOMETER_LABEL = ::T.let(nil, ::T.untyped)
  LINK_CLARKE_LABEL = ::T.let(nil, ::T.untyped)
  LINK_LABEL = ::T.let(nil, ::T.untyped)
  METER_LABEL = ::T.let(nil, ::T.untyped)
  METER_TO_CENTIMETER = ::T.let(nil, ::T.untyped)
  METER_TO_CHAIN = ::T.let(nil, ::T.untyped)
  METER_TO_DECIMETER = ::T.let(nil, ::T.untyped)
  METER_TO_FOOT = ::T.let(nil, ::T.untyped)
  METER_TO_INDIAN_CHAIN = ::T.let(nil, ::T.untyped)
  METER_TO_INDIAN_FOOT = ::T.let(nil, ::T.untyped)
  METER_TO_INDIAN_YARD = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_CHAIN = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_FATHOM = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_FOOT = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_INCH = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_LINK = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_NAUTICAL_MILE = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_STATUTE_MILE = ::T.let(nil, ::T.untyped)
  METER_TO_INTL_YARD = ::T.let(nil, ::T.untyped)
  METER_TO_KILOMETER = ::T.let(nil, ::T.untyped)
  METER_TO_LINK = ::T.let(nil, ::T.untyped)
  METER_TO_LINK_CLARKE = ::T.let(nil, ::T.untyped)
  METER_TO_MILLIMETER = ::T.let(nil, ::T.untyped)
  METER_TO_NAUTICAL_MILE = ::T.let(nil, ::T.untyped)
  METER_TO_ROD = ::T.let(nil, ::T.untyped)
  METER_TO_US_CHAIN = ::T.let(nil, ::T.untyped)
  METER_TO_US_FOOT = ::T.let(nil, ::T.untyped)
  METER_TO_US_INCH = ::T.let(nil, ::T.untyped)
  METER_TO_US_STATUTE_MILE = ::T.let(nil, ::T.untyped)
  METER_TO_US_YARD = ::T.let(nil, ::T.untyped)
  MILLIMETER_LABEL = ::T.let(nil, ::T.untyped)
  NAUTICAL_MILE_LABEL = ::T.let(nil, ::T.untyped)
  RADIAN_LABEL = ::T.let(nil, ::T.untyped)
  RADIAN_TO_DEGREE = ::T.let(nil, ::T.untyped)
  ROD_LABEL = ::T.let(nil, ::T.untyped)
  US_CHAIN_LABEL = ::T.let(nil, ::T.untyped)
  US_FOOT_LABEL = ::T.let(nil, ::T.untyped)
  US_INCH_LABEL = ::T.let(nil, ::T.untyped)
  US_STATUTE_MILE_LABEL = ::T.let(nil, ::T.untyped)
  US_YARD_LABEL = ::T.let(nil, ::T.untyped)
end

class OGR::UnknownGeometry
  include ::OGR::GeometryMixins::Extensions
end

class OGR::UnknownGeometry
  extend ::OGR::Geometry::ClassMethods
end

module OGR
  extend ::OGR::InternalHelpers::ClassMethods
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::GDAL::Logger
  include ::LogSwitch
  include ::LogSwitch::InstanceMethods
  def dclone(); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  extend ::LogSwitch::ClassMethods
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_def_e(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_defs_e(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_mrasgn(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rasgn(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def multi_rassign(lhs, assoc_t, rhs); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rassign(lhs, assoc_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_block?(); end

  def in_class?(); end

  def in_dynamic_block?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

class Parser::CurrentArgStack
  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def stack(); end

  def top(); end
end

class Parser::MaxNumparamStack
end

module Parser::Messages
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::EndlessDefinition
  def assignment(); end

  def initialize(keyword_l, operator_l, name_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::EndlessDefinition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  include ::RuboCop::AST::Ext::Range
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_forward_args?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class REXML::AttlistDecl
  def initialize(source); end
end

class REXML::Attribute
  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Attributes
  def initialize(element); end
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Child
  def initialize(parent=T.unsafe(nil)); end
end

class REXML::Comment
  def initialize(first, second=T.unsafe(nil)); end
end

class REXML::Declaration
  def initialize(src); end
end

class REXML::DocType
  def initialize(first, parent=T.unsafe(nil)); end
end

class REXML::Document
  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Element
  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Elements
  def initialize(parent); end
end

class REXML::Entity
  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end
end

class REXML::ExternalEntity
  def initialize(src); end
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end
end

class REXML::Formatters::Pretty
  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::Instruction
  def initialize(target, content=T.unsafe(nil)); end
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end
end

class REXML::Output
  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::ParseException
  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  def initialize(source); end
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::StreamParser
  def initialize(source, listener); end
end

class REXML::Parsers::TreeParser
  def initialize(source, build_context=T.unsafe(nil)); end
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::Source
  def initialize(arg, encoding=T.unsafe(nil)); end
end

class REXML::Text
  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::XMLDecl
  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end
end

class REXML::XPath
  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  def initialize(strict: T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

module RSpec::Core
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::BacktraceFormatter
end

module RSpec::Core::Bisect
end

class RSpec::Core::Bisect::BisectFailedError
end

class RSpec::Core::Bisect::BisectFailedError
  def self.for_failed_spec_run(spec_output); end
end

class RSpec::Core::Bisect::Channel
  def close(); end

  def receive(); end

  def send(message); end
end

class RSpec::Core::Bisect::Channel
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def all_example_ids(); end

  def all_example_ids=(_); end

  def failed_example_ids(); end

  def failed_example_ids=(_); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Bisect::Notifier
  def initialize(formatter); end

  def publish(event, *args); end
end

class RSpec::Core::Bisect::Notifier
end

module RSpec::Core::Bisect
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def profile_examples(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_aliases(name, alias_name); end

  def self.define_predicate_for(*names); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
end

module RSpec::Core::DSL
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::DidYouMean
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.descendants(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusDumper
  def dump(); end

  def initialize(examples); end
end

class RSpec::Core::ExampleStatusDumper
  def self.dump(examples); end
end

class RSpec::Core::ExampleStatusMerger
  def initialize(this_run, from_previous_runs); end

  def merge(); end
end

class RSpec::Core::ExampleStatusMerger
  def self.merge(this_run, from_previous_runs); end
end

class RSpec::Core::ExampleStatusParser
  def initialize(string); end

  def parse(); end
end

class RSpec::Core::ExampleStatusParser
  def self.parse(string); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterManager
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

module RSpec::Core::FilterableItemRepository
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
end

module RSpec::Core::FilterableItemRepository
end

module RSpec::Core::FlatMap
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*_); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FailureListFormatter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Util
  def flush(); end

  def initialize(output); end

  def make_example_group_header_red(group_id); end

  def make_example_group_header_yellow(group_id); end

  def make_header_red(); end

  def make_header_yellow(); end

  def move_progress(percent_done); end

  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content); end

  def print_example_group_end(); end

  def print_example_group_start(group_id, description, number_of_parents); end

  def print_example_passed(description, run_time); end

  def print_example_pending(description, pending_message); end

  def print_html_start(); end

  def print_summary(duration, example_count, failure_count, pending_count); end
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::InclusionRules
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
end

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  def initialize(metadata); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers
  def initialize(*_); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

class RSpec::Core::Metadata::HashPopulator
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

module RSpec::Core::MockingAdapters
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

module RSpec::Core::MockingAdapters
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

module RSpec::Core::Notifications
end

class RSpec::Core::Notifications::CustomNotification
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.from_hash(data); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.for(example); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::ExamplesNotification
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::ProfileNotification
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  include ::RSpec::Core::ShellEscape
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications
end

class RSpec::Core::NullReporter
end

class RSpec::Core::NullReporter
end

module RSpec::Core::Ordering
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::ConfigurationManager
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Custom
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Identity
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::Ordering::Registry
end

module RSpec::Core::Ordering
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def gets(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def method_missing(name, *args, &block); end

  def nread(*args, &block); end

  def output(); end

  def output=(output); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::OutputWrapper
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
end

module RSpec::Core::RubyProject
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  include ::Enumerable
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

class RSpec::Core::Set
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

class RSpec::Core::SharedExampleGroup::Registry
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

module RSpec::Core::SharedExampleGroup
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

class RSpec::Core::SharedExampleGroupModule
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  def self.conditionally_quote(id); end

  def self.escape(shell_command); end

  def self.quote(argument); end

  def self.shell_allows_unquoted_ids?(); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
end

class RSpec::Core::Time
  def self.now(); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

module RSpec::Core::Warnings
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_group_counts_by_spec_file(); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

class RSpec::Core::World
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*_); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(*args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

module RSpec::Matchers::BuiltIn::CaptureStderr
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  def self.capture(block); end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  def self.capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
  def capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def actual_after(); end

  def actual_delta(); end

  def changed?(); end

  def initialize(matcher_name, receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def perform_change(event_proc); end

  def value_representation(); end
end

class RSpec::Matchers::BuiltIn::ChangeDetails
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
  def does_not_match?(event_proc); end

  def initialize(change_details, expected_before); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
  def does_not_match?(_event_proc); end

  def initialize(change_details, expected_delta, relativity, &comparer); end

  def matches?(event_proc); end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
end

class RSpec::Matchers::BuiltIn::ChangeToValue
  def does_not_match?(_event_proc); end

  def from(value); end

  def initialize(change_details, expected_after); end
end

class RSpec::Matchers::BuiltIn::ChangeToValue
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

module RSpec::Matchers::BuiltIn::NullCapture
end

module RSpec::Matchers::BuiltIn::NullCapture
  def self.capture(_block); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
  def captures(); end

  def initialize(match_data); end

  def match_data(); end

  def names(); end
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def ignoring_method_signature_failure!(); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, from, to); end

  def matches?(event_proc); end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

class RSpec::Matchers::BuiltIn::SpecificValuesChange
end

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def does_not_match?(block); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def assert_used!(); end

  def assert_valid_expect_block!(); end

  def has_block?(); end

  def initialize(block, &callback); end

  def num_yields(); end

  def num_yields=(num_yields); end

  def probe(); end

  def single_yield_args(); end

  def to_proc(); end

  def yielded_args(); end

  def yielded_args=(yielded_args); end

  def yielded_once?(matcher_name); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def self.probe(block, &callback); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL::Macros
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  def message_with_diff(message, differ, actual); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def self.for_many_matchers(matchers); end

  def self.from(expected); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AllowanceTarget
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndReturnImplementation
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def present?(); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AndYieldImplementation
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  include ::T::CompatibilityPatches::RSpecCompatibility::RecorderExtensions
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*args); end

  def expected_args(); end

  def initialize(*expected_args); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::CallbackInvocationStrategy
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::ClassNewMethodReference
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end
end

class RSpec::Mocks::ClassVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ClassVerifyingDouble
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Configuration
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  extend ::RSpec::Support::RecursiveConstMethods
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  include ::RSpec::Support::RecursiveConstMethods
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
end

class RSpec::Mocks::ConstantMutator
  extend ::RSpec::Support::RecursiveConstMethods
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::DirectObjectReference
end

class RSpec::Mocks::Double
  include ::RSpec::Mocks::TestDouble
end

class RSpec::Mocks::Double
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

class RSpec::Mocks::ErrorGenerator
end

module RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

class RSpec::Mocks::ExpectationTarget
  include ::RSpec::Mocks::ExpectationTargetMethods
end

class RSpec::Mocks::ExpectationTarget
end

module RSpec::Mocks::ExpectationTargetMethods
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

module RSpec::Mocks::ExpectationTargetMethods
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::Implementation
  def call(*args, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def present?(); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::Implementation
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::InstanceMethodStasher
end

class RSpec::Mocks::InstanceVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::InstanceVerifyingDouble
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def block(); end

  def block=(block); end

  def initialize(method_name, args, block); end

  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::ExpectationCustomization
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

module RSpec::Mocks::Matchers::Matcher
end

module RSpec::Mocks::Matchers::Matcher
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

class RSpec::Mocks::MessageExpectation
  include ::RSpec::Mocks::MessageExpectation::ImplementationDetails
  def and_call_original(); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, &block); end

  def matches?(message, *args); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
end

class RSpec::Mocks::MessageExpectation
end

class RSpec::Mocks::MethodDouble
  include ::T::CompatibilityPatches::RSpecCompatibility::MethodDoubleExtensions
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def message_expectation_class(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NamedObjectReference
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NestedSpace
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

class RSpec::Mocks::ObjectVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ObjectVerifyingDouble
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  def as_stubbed_const(options=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

class RSpec::Mocks::OrderGroup
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::PartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialClassDoubleProxy
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::PartialDoubleProxy
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def as_null_object(); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def null_object?(); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::ProxyForNil
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::RootSpace
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::SimpleMessageExpectation
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::Space
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def initialize(target); end
end

class RSpec::Mocks::TargetBase
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDouble
end

module RSpec::Mocks::TestDoubleFormatter
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::UnsupportedMatcherError
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, &block); end
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end
end

class RSpec::Mocks::VerifyingMessageExpectation
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingMethodDouble
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
end

class RSpec::Mocks::VerifyingProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::VerifyingProxy
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::VerifyingProxyMethods
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::ComparableVersion
  include ::Comparable
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::ComparableVersion
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::DirectoryMaker
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  def self.new(); end
end

module RSpec::Support::OS
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.can_inspect?(_object); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

module RSpec::Support::RecursiveConstMethods
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

class RSpec::Support::ReentrantMutex
end

module RSpec::Support::Ruby
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end

  def self.truffleruby?(); end
end

module RSpec::Support::RubyFeatures
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::Warnings
end

module RSpec::Support::WithKeywordsWhenNeeded
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, &block); end
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
end

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.shared_context(name, *args, &block); end

  def self.shared_examples(name, *args, &block); end

  def self.shared_examples_for(name, *args, &block); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def excluded_from_list?(fn); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_lr(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_output_message(message); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def order_only_prerequisites(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end

  def |(deps); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.format_deps(deps); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class Regexp
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

module Regexp::Expression
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

class Regexp::Expression::Alternation
end

class Regexp::Expression::Alternative
end

class Regexp::Expression::Alternative
end

module Regexp::Expression::Anchor
end

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

class Regexp::Expression::Anchor::Base
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfString
end

class Regexp::Expression::Anchor::BeginningOfString
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

module Regexp::Expression::Anchor
end

module Regexp::Expression::Assertion
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

module Regexp::Expression::Assertion
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Backreference::Base
  def match_length(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Backreference::Base
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Name
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Number
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Backreference::NumberRelative
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def case_insensitive?(); end

  def coded_offset(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def full_length(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def nesting_level=(nesting_level); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def possessive?(); end

  def quantified?(); end

  def quantifier(); end

  def quantifier=(quantifier); end

  def quantifier_affix(expression_format); end

  def quantify(token, text, min=T.unsafe(nil), max=T.unsafe(nil), mode=T.unsafe(nil)); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def starts_at(); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def terminal?(); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def type?(test_type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::Base
end

class Regexp::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negated?(); end

  def negative(); end

  def negative=(negative); end

  def negative?(); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::Intersection
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Intersection
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end

  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::CharacterSet::Range
end

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::CharacterType::Base
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Word
end

class Regexp::Expression::CharacterType::Word
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::Comment
end

class Regexp::Expression::Comment
end

module Regexp::Expression::Conditional
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Condition
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Expression
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

class Regexp::Expression::Conditional::TooManyBranches
end

module Regexp::Expression::Conditional
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::Base
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::FreeSpace
  def match_length(); end
end

class Regexp::Expression::FreeSpace
end

module Regexp::Expression::Group
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Base
  def capturing?(); end

  def comment?(); end
end

class Regexp::Expression::Group::Base
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Capture
end

class Regexp::Expression::Group::Comment
  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::Group::Comment
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Named
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Options
end

class Regexp::Expression::Group::Passive
end

class Regexp::Expression::Group::Passive
end

module Regexp::Expression::Group
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Keep::Mark
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Literal
  def match_length(); end
end

class Regexp::Expression::Literal
end

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end

  def negative?(); end
end

class Regexp::Expression::PosixClass
end

class Regexp::Expression::Quantifier
  def greedy?(); end

  def initialize(token, text, min, max, mode); end

  def lazy?(); end

  def max(); end

  def min(); end

  def mode(); end

  def possessive?(); end

  def reluctant?(); end

  def text(); end

  def to_h(); end

  def to_str(); end

  def token(); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Quantifier
end

class Regexp::Expression::Root
  def initialize(*args); end
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end

  def self.build_token(); end
end

class Regexp::Expression::Sequence
  def initialize(*args); end
end

class Regexp::Expression::Sequence
  def self.add_to(subexpression, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end

  def self.at_levels(level, set_level, conditional_level); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::SequenceOperation
end

class Regexp::Expression::Subexpression
  include ::Enumerable
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def te(); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::Subexpression
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def negative?(); end

  def shortcut(); end
end

class Regexp::Expression::UnicodeProperty::Base
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Graph
end

class Regexp::Expression::UnicodeProperty::Graph
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Lower
end

class Regexp::Expression::UnicodeProperty::Lower
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Newline
end

class Regexp::Expression::UnicodeProperty::Newline
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Punct
end

class Regexp::Expression::UnicodeProperty::Punct
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Script
end

class Regexp::Expression::UnicodeProperty::Script
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Space
end

class Regexp::Expression::UnicodeProperty::Space
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Expression::WhiteSpace
end

module Regexp::Expression
  def self.parsed(exp); end
end

class Regexp::Lexer
  def lex(input, syntax=T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  include ::Enumerable
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(&block); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  include ::Regexp::Expression
  include ::Regexp::Syntax
  include ::Regexp::Expression::UnicodeProperty
  def parse(input, syntax=T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenError
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text, ts, te); end

  def scan(input_object, &block); end
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidBackrefError
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidGroupOption
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::InvalidSequenceError
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
end

class Regexp::Scanner::ValidationError
  def initialize(reason); end
end

class Regexp::Scanner::ValidationError
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.scan(input_object, &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token
  def check!(type, token); end

  def check?(type, token); end

  def excludes(type, tokens); end

  def features(); end

  def implementations(type); end

  def implements(type, tokens); end

  def implements!(type, token); end

  def implements?(type, token); end

  def normalize(type, token); end

  def normalize_backref(type, token); end

  def normalize_group(type, token); end
end

class Regexp::Syntax::Base
end

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::InvalidVersionNameError
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::NotImplementedError
end

class Regexp::Syntax::SyntaxError
end

class Regexp::Syntax::SyntaxError
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
end

module Regexp::Syntax::Token::UnicodeProperty
end

module Regexp::Syntax::Token
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

class Regexp::Syntax::UnknownSyntaxNameError
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_3
end

class Regexp::Syntax::V2_6_3
end

module Regexp::Syntax
  def self.comparable_version(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.inherit_from_version(parent_version, new_version); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end

  def self.version_const_name(version_string); end

  def self.warn_if_future_version(const_name); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(_); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*_); end

  def self.members(); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def getname(address); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
  VOID_CONTEXT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseMatchNode
  include ::RuboCop::AST::ConditionalNode
  def each_in_pattern(&block); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseMatchNode
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def branches(); end

  def each_when(&block); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_ary(*args, &block); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::DefinedNode
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

module RuboCop::AST::Ext
end

module RuboCop::AST::Ext::Range
  def line_span(exclude_end: T.unsafe(nil)); end
end

module RuboCop::AST::Ext::Range
end

module RuboCop::AST::Ext
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

class RuboCop::AST::ForwardArgsNode
  include ::RuboCop::AST::CollectionNode
end

class RuboCop::AST::ForwardArgsNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(&block); end

  def each_pair(); end

  def each_value(&block); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(&block); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::IndexNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexNode
end

class RuboCop::AST::IndexasgnNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexasgnNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
  DOUBLE_SPLAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::KeywordSplatNode
end

class RuboCop::AST::LambdaNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::LambdaNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def macro_scope?(node=T.unsafe(nil)); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerable_method?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def nonmutating_array_method?(); end

  def nonmutating_binary_operator_method?(); end

  def nonmutating_hash_method?(); end

  def nonmutating_operator_method?(); end

  def nonmutating_string_method?(); end

  def nonmutating_unary_operator_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
  ENUMERABLE_METHODS = ::T.let(nil, ::T.untyped)
  ENUMERATOR_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_BINARY_OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_HASH_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_STRING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_UNARY_OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::NextNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::NextNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def argument_type?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def child_nodes(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_definition?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_e_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_e_type?(); end

  def defs_type?(); end

  def descendants(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def find_pattern_type?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_arg_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def global_const?(node=T.unsafe(nil), param1); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def line_count(); end

  def literal?(); end

  def loop_keyword?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(node=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_definition?(node=T.unsafe(nil)); end

  def module_type?(); end

  def mrasgn_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def post_condition_loop?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rasgn_type?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def root_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def struct_constructor?(node=T.unsafe(nil)); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def visit_descendants(types, &block); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::AST::NodePattern
  def ==(other); end

  def eql?(other); end

  def initialize(str); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args, **rest); end

  def pattern(); end
end

class RuboCop::AST::NodePattern::Invalid
end

class RuboCop::AST::NodePattern::Invalid
end

module RuboCop::AST::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str, **keyword_defaults); end

  def def_node_search(method_name, pattern_str, **keyword_defaults); end
end

module RuboCop::AST::NodePattern::Macros
end

class RuboCop::AST::NodePattern::Matcher
  def ===(compare); end

  def initialize(&block); end
end

class RuboCop::AST::NodePattern::Matcher
end

class RuboCop::AST::NodePattern
  def self.descend(element, &block); end
end

module RuboCop::AST::NumericNode
  def sign?(); end
  SIGN_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def value_on_new_line?(); end
  COLON = ::T.let(nil, ::T.untyped)
  HASH_ROCKET = ::T.let(nil, ::T.untyped)
  SPACED_COLON = ::T.let(nil, ::T.untyped)
  SPACED_HASH_ROCKET = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end

  def arguments?(); end

  def first_argument(); end

  def last_argument(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
  LOGICAL_AND = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  SEMANTIC_AND = ::T.let(nil, ::T.untyped)
  SEMANTIC_OR = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::ProcessedSource
  include ::RuboCop::Ext::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def blank?(); end

  def buffer(); end

  def checksum(); end

  def comment_at_line(line); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def contains_comment?(source_range); end

  def current_line(token); end

  def diagnostics(); end

  def each_comment(&block); end

  def each_comment_in_lines(line_range); end

  def each_token(&block); end

  def file_path(); end

  def find_comment(&block); end

  def find_token(&block); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def line_indentation(line_number); end

  def line_with_comment?(line); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  def self.from_file(path, ruby_version); end
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RegexpNode
  include ::RuboCop::Ext::RegexpNode
  def content(); end

  def delimiter?(char); end

  def delimiters(); end

  def extended?(); end

  def ignore_case?(); end

  def interpolation?(); end

  def multiline_mode?(); end

  def no_encoding?(); end

  def percent_r_literal?(); end

  def regopt(); end

  def single_interpolation?(); end

  def slash_literal?(); end

  def to_regexp(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def exception_variable(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::ReturnNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::ReturnNode
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(node=T.unsafe(nil)); end
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

class RuboCop::AST::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::AST::Token
  def self.from_parser_token(parser_token); end
end

module RuboCop::AST::Traversal
  def on___ENCODING__(node); end

  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_find_pattern(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  MANY_CHILD_NODES = ::T.let(nil, ::T.untyped)
  NO_CHILD_NODES = ::T.let(nil, ::T.untyped)
  ONE_CHILD_NODE = ::T.let(nil, ::T.untyped)
  SECOND_CHILD_ONLY = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(&block); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  include ::RuboCop::Formatter::TextUtil
  def run(); end
end

class RuboCop::CLI::Command::ExecuteRunner
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
end

class RuboCop::CLI::Command::Version
  def run(); end
end

class RuboCop::CLI::Command::Version
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CLI::Environment
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*args, &block); end

  def []=(*args, &block); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def delete(*args, &block); end

  def deprecation_check(); end

  def disabled_new_cops?(); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def enabled_new_cops?(); end

  def fetch(*args, &block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_badge(badge); end

  def for_cop(cop); end

  def for_department(department_name); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def transform_values(*args, &block); end

  def validate(*args, &block); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  extend ::Forwardable
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_missing_namespaces(path, hash); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.load_yaml_configuration(absolute_path); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.possible_new_cops?(config); end

  def self.project_root(); end

  def self.project_root=(project_root); end

  def self.warn_on_pending_cops(pending_cops); end

  def self.warn_pending_cop(cop); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def override_department_setting_for_cops(base_hash, derived_hash); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete_cops_and_parameters(); end
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def for_dir(dir); end

  def for_file(file); end

  def for_pwd(); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def for_all_cops(*args, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_section_presence(name); end
end

class RuboCop::ConfigValidator
  extend ::Forwardable
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(corrector, processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

module RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::AllowedMethods
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutoCorrector
  def support_autocorrect?(); end
end

module RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def correctable?(); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

class RuboCop::Cop::Base
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::TokensUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_global_offense(message=T.unsafe(nil), severity: T.unsafe(nil)); end

  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def message(_range=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def on_investigation_end(); end

  def on_new_investigation(); end

  def on_other_file(); end

  def processed_source(); end

  def ready(); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base::InvestigationReport
  def cop(); end

  def cop=(_); end

  def corrector(); end

  def corrector=(_); end

  def offenses(); end

  def offenses=(_); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Base::InvestigationReport
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Base
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros
  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.documentation_url(); end

  def self.exclude_from_registry(); end

  def self.inherited(subclass); end

  def self.joining_forces(); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.support_autocorrect?(); end

  def self.support_multiple_source?(); end
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(node0); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def insecure_protocol_source?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(node0); end

  def investigate(processed_source); end
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
end

module RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  def source_range_with_comment(node); end
end

module RuboCop::Cop::CommentsHelp
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def cop_reports(); end

  def cop_reports=(_); end

  def cops(); end

  def correctors(); end

  def errors(); end

  def errors=(_); end

  def merge(investigation); end

  def offenses(); end

  def offenses_per_cop(); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(corrector, node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

class RuboCop::Cop::Cop
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def corrections(); end

  def find_location(node, loc); end

  def parse(source, path=T.unsafe(nil)); end

  def support_autocorrect?(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  def self.all(); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def initialize(source); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def rewrite(); end
end

class RuboCop::Cop::Corrector
  def self.source_buffer(source); end
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Documentation
end

module RuboCop::Cop::Documentation
  def self.department_to_basename(department); end

  def self.url_for(cop_class); end
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(corrector, node); end

  def self.insert_before(corrector, node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(node0); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def required_ruby_version(node0); end

  def string_version?(node=T.unsafe(nil)); end
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(node0); end

  def on_const(node); end

  def ruby_version?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added:); end

  def inject(); end
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
end

module RuboCop::Cop::HashAlignmentStyles
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
end

module RuboCop::Cop::HashAlignmentStyles
end

module RuboCop::Cop::HashTransformMethod
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*_); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.from_to_h(node, match); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
end

class RuboCop::Cop::Layout::ArgumentAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::ArrayAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
end

class RuboCop::Cop::Layout::AssignmentIndentation
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def leftmost_multiple_assignment(node); end
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def block_end_align_target?(node=T.unsafe(nil), param1); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::BlockAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end
end

class RuboCop::Cop::Layout::CaseIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClassStructure
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(class_node); end
end

class RuboCop::Cop::Layout::ClassStructure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(comment); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::ConditionPosition
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::ConditionPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DefEndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::EmptyComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RescueNode
  def on_case(node); end

  def on_if(node); end

  def on_rescue(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(corrector, prev_def, node); end

  def check_defs(nodes); end

  def on_begin(node); end
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::EmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_send(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_kwbegin(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_sclass(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_module(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::ExtraSpacing
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_array(node); end
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_hash(node); end
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::HashAlignment
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offences_by(); end

  def offences_by=(offences_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

class RuboCop::Cop::Layout::HashAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
end

class RuboCop::Cop::Layout::HeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
end

class RuboCop::Cop::Layout::IndentationStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def access_modifier?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::InitialIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def investigate_post_walk(processed_source); end

  def on_array(node); end

  def on_block(node); end

  def on_hash(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_array(node); end
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_hash(node); end
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_send(node); end
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::ParameterAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::RangeHelp
  def on_ensure(node); end

  def on_resbody(node); end
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def on_kwoptarg(node); end

  def on_pair(node); end
end

class RuboCop::Cop::Layout::SpaceAfterColon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
end

class RuboCop::Cop::Layout::SpaceAfterNot
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_optarg(node); end
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  include ::RuboCop::Cop::RangeHelp
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

class RuboCop::Cop::Layout::SpaceInsideParens
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def on_erange(node); end

  def on_irange(node); end
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_interpolation(begin_node); end
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::TrailingWhitespace
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::Legacy::CorrectionsProxy
  def <<(callable); end

  def concat(corrections); end

  def corrector(); end

  def empty?(); end

  def initialize(corrector); end
end

class RuboCop::Cop::Legacy::CorrectionsProxy
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  extend ::RuboCop::TokensUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::LineLengthHelp
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::AmbiguousOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Lint::BigDecimalNew
  def big_decimal_new(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::BigDecimalNew
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  def on_and(node); end

  def on_or(node); end

  def on_send(node); end
  MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(node=T.unsafe(nil)); end

  def on_sym(node); end
end

class RuboCop::Cop::Lint::BooleanSymbol
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
end

class RuboCop::Cop::Lint::ConstantResolution
  def on_const(node); end

  def unqualified_const?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end

  def on_send(node); end
  DEBUGGER_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def on_send(node); end
  DEPRECATED_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  include ::RuboCop::Cop::RangeHelp
  def algorithm_const(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
end

class RuboCop::Cop::Lint::DuplicateHashKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(node=T.unsafe(nil)); end
  METHOD_DEF_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  def on_send(node); end

  def require_call?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
end

class RuboCop::Cop::Lint::DuplicateRescueException
  include ::RuboCop::Cop::RescueNode
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
end

class RuboCop::Cop::Lint::EmptyEnsure
  def on_ensure(node); end
end

class RuboCop::Cop::Lint::EmptyEnsure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
end

class RuboCop::Cop::Lint::EmptyFile
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end
end

class RuboCop::Cop::Lint::EmptyInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
end

class RuboCop::Cop::Lint::EnsureReturn
  include ::RuboCop::Cop::RangeHelp
  def on_ensure(node); end
end

class RuboCop::Cop::Lint::EnsureReturn
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def erb_new_with_non_keyword_arguments(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
end

class RuboCop::Cop::Lint::FloatComparison
  def on_send(node); end
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(node=T.unsafe(nil)); end

  def on_send(node); end
  FORMAT_METHODS = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(node0); end
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def class_new_call?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::InheritException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::InterpolationCheck
  def on_str(node); end
end

class RuboCop::Cop::Lint::InterpolationCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::LiteralAsCondition
  include ::RuboCop::Cop::RangeHelp
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_interpolation(begin_node); end
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Lint::Loop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Lint::MissingSuper
  def on_def(node); end

  def on_defs(node); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  OBJECT_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  def on_regexp(node); end
end

class RuboCop::Cop::Lint::MultipleComparison
  def multiple_compare?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::MultipleComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def loop_variable(node=T.unsafe(nil)); end

  def method_require?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def unsorted_dir_block?(node=T.unsafe(nil)); end

  def unsorted_dir_each?(node=T.unsafe(nil)); end

  def unsorted_dir_each_pass?(node=T.unsafe(nil)); end

  def unsorted_dir_glob_pass?(node=T.unsafe(nil)); end

  def var_is_required?(node0, param1); end
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(return_node); end
end

class RuboCop::Cop::Lint::NumberConversion
  def datetime?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_method(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::NumberConversion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
end

class RuboCop::Cop::Lint::OrderedMagicComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  def on_match_with_lvasgn(node); end

  def on_nth_ref(node); end

  def on_send(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Lint::PercentStringArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Lint::PercentSymbolArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(node=T.unsafe(nil)); end

  def exception_new_with_message?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::RaiseException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  include ::RuboCop::Cop::RangeHelp
  def initialize(config=T.unsafe(nil), options=T.unsafe(nil), offenses=T.unsafe(nil)); end

  def offenses_to_check(); end

  def offenses_to_check=(offenses_to_check); end
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def unnecessary_require_statement?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def literal_expansion(node=T.unsafe(nil)); end

  def on_splat(node); end
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end

  def to_s_without_args?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_with_index?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantWithIndex
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_with_object?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
end

class RuboCop::Cop::Lint::RegexpAsCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
end

class RuboCop::Cop::Lint::RescueType
  include ::RuboCop::Cop::RescueNode
  def autocorrect(corrector, node); end

  def on_resbody(node); end
end

class RuboCop::Cop::Lint::RescueType
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def bad_method?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def check(node); end

  def on_csend(node); end
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ScriptPermission
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SelfAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def send_with_mixin_argument?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def uses_var?(node0, param1); end
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
end

class RuboCop::Cop::Lint::ToJSON
  def on_def(node); end
end

class RuboCop::Cop::Lint::ToJSON
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end
end

class RuboCop::Cop::Lint::UnifiedInteger
  def fixnum_or_bignum_const(node=T.unsafe(nil)); end

  def on_const(node); end
end

class RuboCop::Cop::Lint::UnifiedInteger
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
end

class RuboCop::Cop::Lint::UnreachableLoop
  def break_command?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def not_implemented?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UriRegexp
  def on_send(node); end
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAccessModifier
  include ::RuboCop::Cop::RangeHelp
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UselessAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAssignment
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def define_method?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def class_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end

  def on_args(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def calculate(); end

  def else_branch?(node); end

  def evaluate_branch_nodes(node); end

  def evaluate_condition_node(node); end

  def initialize(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::TokensUtil
  def calculate(); end

  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  def block_method_name(node); end

  def iterating_block?(node); end

  def iterating_method?(name); end
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def discount_for_repeated_csend?(csend_node); end

  def reset_on_lvasgn(node); end

  def reset_repeated_csend(); end
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
end

class RuboCop::Cop::Migration::DepartmentName
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Migration::DepartmentName
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(); end

  def initialize(corrector, node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def self.correct(corrector, node, processed_source); end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(node=T.unsafe(nil)); end
  EXCLUDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::BlockParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def literal_receiver?(node=T.unsafe(nil)); end

  def on_casgn(node); end
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def memoized?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(node=T.unsafe(nil)); end

  def sym_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Naming::MethodParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodParameterName
end

class RuboCop::Cop::Naming::PredicateName
  include ::RuboCop::Cop::AllowedMethods
  def dynamic_method_define(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def on_resbody(node); end
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def corrector(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil), corrector=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(corrector, node); end
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::TokensUtil
  def config(); end

  def correct(corrector, node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(corrector, token); end

  def self.remove_space(corrector, space_before); end

  def self.swap_comma(corrector, range); end
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::RegexpLiteralHelp
end

module RuboCop::Cop::RegexpLiteralHelp
end

class RuboCop::Cop::Registry
  include ::Enumerable
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def department_missing?(badge, name); end

  def departments(); end

  def dismiss(cop); end

  def each(&block); end

  def enabled(config, only=T.unsafe(nil), only_safe: T.unsafe(nil)); end

  def enabled?(cop, config, only_safe); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def options(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
  def self.all(); end

  def self.global(); end

  def self.qualified_cop_name(name, origin); end

  def self.with_temporary_global(temp_global=T.unsafe(nil)); end
end

module RuboCop::Cop::RescueNode
  def on_new_investigation(); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end

  def setter_method?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Security::JSONLoad
  def json_load(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Security::JSONLoad
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::YAMLLoad
  def on_send(node); end

  def yaml_load(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::YAMLLoad
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def on_new_investigation(); end
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def on_new_investigation(); end
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  extend ::RuboCop::TokensUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def access_modifier_with_symbol?(node=T.unsafe(nil)); end

  def on_send(node); end
  ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  ACCESSOR_METHODS = ::T.let(nil, ::T.untyped)
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def identifier(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::Alias
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Style::AndOr
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArrayCoercion
  def array_splat?(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_if(node); end

  def unless_array?(node=T.unsafe(nil)); end
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ArrayJoin
  def join_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::ArrayJoin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def class_eval?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::Attr
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_dstr(node); end

  def on_str(node); end
end

class RuboCop::Cop::Style::BarePercentLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(class_node); end

  def on_module(class_node); end

  def on_sclass(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::BlockComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::BlockDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::CaseEquality
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseLikeIf
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def class_check?(node=T.unsafe(nil)); end

  def message(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::ClassCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethods
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Style::ClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  def on_defs(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassVars
  def on_cvasgn(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::CollectionMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodCall
  def java_type_node?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::ColonMethodCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def on_defs(node); end
end

class RuboCop::Cop::Style::ColonMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CombinableLoops
  def on_block(node); end

  def on_for(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_xstr(node); end
end

class RuboCop::Cop::Style::CommandLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::CommentAnnotation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentedKeyword
  def investigate(processed_source); end
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(node=T.unsafe(nil), param1); end
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::Copyright
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::DefWithParentheses
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::DefWithParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Dir
  def dir_replacement?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::Dir
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(node=T.unsafe(nil)); end

  def constant_visibility_declaration?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(node0); end
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def module_function_node?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DoubleNegation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def double_negative?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def offending_each_range(node=T.unsafe(nil)); end

  def on_block(node); end
end

class RuboCop::Cop::Style::EachForSimpleLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def each_with_object_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end
end

class RuboCop::Cop::Style::EachWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Style::EmptyBlockParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end
end

class RuboCop::Cop::Style::EmptyCaseCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::EmptyElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::EmptyLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::EmptyMethod
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::Encoding
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
end

class RuboCop::Cop::Style::EndBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  EVAL_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  def even_odd_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::EvenOdd
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def file_expand_path(node=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(node=T.unsafe(nil)); end

  def pathname_parent_expand_path(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ExpandPathArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  include ::RuboCop::Cop::RangeHelp
  def on_yield(node); end

  def yielding_block?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExponentialNotation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_float(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(node=T.unsafe(nil)); end

  def both_coerce?(node=T.unsafe(nil)); end

  def left_coerce?(node=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(node=T.unsafe(nil)); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_for(node); end
end

class RuboCop::Cop::Style::For
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def formatter(node=T.unsafe(nil)); end

  def on_send(node); end

  def variable_argument?(node=T.unsafe(nil)); end
  FORMAT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def format_string_in_typical_context?(node=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::GlobalStdStream
  def const_to_gvar_assignment?(node=T.unsafe(nil), param1); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashEachMethods
  include ::RuboCop::Cop::Lint::UnusedArgument
  def kv_each(node=T.unsafe(nil)); end

  def on_block(node); end
end

class RuboCop::Cop::Style::HashEachMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashLikeCase
  def hash_like_case?(node=T.unsafe(nil)); end

  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
end

class RuboCop::Cop::Style::HashTransformKeys
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end

  def on_bad_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformKeys
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashTransformValues
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end

  def on_bad_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::IgnoredPattern
  def on_if(node); end
end

class RuboCop::Cop::Style::IfUnlessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_if(node); end
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::IfWithSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Style::InfiniteLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::InverseMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
end

class RuboCop::Cop::Style::KeywordParametersOrder
  include ::RuboCop::Cop::RangeHelp
  def on_kwoptarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Style::Lambda
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(corrector, node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::LambdaCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::LineEndConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(_node); end

  def initialize(*_); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def on_send(node); end
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::MethodDefParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MinMax
  def min_max_candidate(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
end

class RuboCop::Cop::Style::MinMax
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Style::MixinGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def on_send(node); end

  def wrapped_macro_scope?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ModuleFunction
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def on_if(node); end
end

class RuboCop::Cop::Style::MultilineIfModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::MultilineIfThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message(_node); end

  def on_or_asgn(node); end
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def on_when(node); end
end

class RuboCop::Cop::Style::MultilineWhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_casgn(node); end

  def on_or_asgn(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(node=T.unsafe(nil)); end

  def splat_value(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MutableConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NestedModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
end

class RuboCop::Cop::Style::NestedTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::Next
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def nil_check?(node=T.unsafe(nil)); end

  def nil_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::NilComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NonNilCheck
  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
end

class RuboCop::Cop::Style::Not
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def on_int(node); end
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(node=T.unsafe(nil)); end
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::OneLineConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  def on_def(node); end

  def on_defs(node); end
  BOOLEAN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
end

class RuboCop::Cop::Style::OrAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::OrAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def implicit_self_getter?(node=T.unsafe(nil)); end

  def on_masgn(node); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(node0, param1, param2); end

  def tsort_each_child(assignment); end

  def tsort_each_node(&block); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def control_op_condition(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_str(node); end
end

class RuboCop::Cop::Style::PercentQLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PerlBackrefs
  def on_nth_ref(node); end
end

class RuboCop::Cop::Style::PerlBackrefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::PreferredHashMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Proc
  def on_block(node); end

  def proc_new?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Proc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
end

class RuboCop::Cop::Style::RaiseArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RandomWithOffset
  def integer_op_rand?(node=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end

  def random_call(node=T.unsafe(nil)); end

  def to_int(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RandomWithOffset
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantAssignment
  def on_def(node); end

  def on_defs(node); end

  def redundant_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantBegin
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::RedundantBegin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
end

class RuboCop::Cop::Style::RedundantCapitalW
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCondition
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
end

class RuboCop::Cop::Style::RedundantCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end

  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end

  def fix_compact(node); end

  def fix_exploded(node); end

  def on_send(node); end
  RAISE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFetchBlock
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def rails_cache?(node=T.unsafe(nil)); end

  def redundant_fetch_block_candidate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  def on_send(node); end

  def require_call?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def on_send(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantFreeze
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_dstr(node); end
end

class RuboCop::Cop::Style::RedundantInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def first_send_argument?(node=T.unsafe(nil)); end

  def first_super_argument?(node=T.unsafe(nil)); end

  def first_yield_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantPercentQ
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RegexpLiteralHelp
  def on_regexp(node); end
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RegexpLiteralHelp
  def on_regexp(node); end
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::RedundantSelf
  def autocorrect(node); end

  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  include ::RuboCop::Cop::RangeHelp
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_send(node); end

  def redundant_nonself_assignment?(node=T.unsafe(nil), param1, param2); end

  def redundant_self_assignment?(node=T.unsafe(nil), param1); end
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSort
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def redundant_sort?(node=T.unsafe(nil)); end
  SORT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_sort_by(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
end

class RuboCop::Cop::Style::RegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_resbody(node); end

  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ReturnNil
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  def check_node(node); end

  def modifier_if_safe_navigation_candidate(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def use_var_only_in_unless_modifier?(node, variable); end
end

class RuboCop::Cop::Style::SafeNavigation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Sample
  def on_send(node); end

  def sample_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Sample
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SelfAssignment
  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
end

class RuboCop::Cop::Style::SelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def on_begin(node); end
end

class RuboCop::Cop::Style::Semicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end

  def sending?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def custom_fail_methods(node0); end

  def kernel_call?(node=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::SignalException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleArgumentDig
  def on_send(node); end

  def single_argument_dig?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::SingleLineMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SlicingWithRange
  def on_send(node); end

  def range_till_minus_one?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::SlicingWithRange
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::SoleNestedConditional
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(corrector, node, global_var); end

  def message(global_var); end

  def on_gvar(node); end
end

class RuboCop::Cop::Style::SpecialGlobalVars
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def stderr_puts?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::StderrPuts
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringConcatenation
  def on_send(node); end

  def string_concatenation?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringHashKeys
  def on_pair(node); end

  def receive_environments_method?(node=T.unsafe(nil)); end

  def string_hash_key?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::StringHashKeys
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::StringMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def lstrip_rstrip(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::Strip
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StructInheritance
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def struct_constructor?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::StructInheritance
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
end

class RuboCop::Cop::Style::SymbolArray
  extend ::RuboCop::Cop::AutoCorrector
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def on_sym(node); end
end

class RuboCop::Cop::Style::SymbolLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::SymbolProc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def method_name(node=T.unsafe(nil)); end

  def on_if(node); end

  def only_closing_parenthesis_is_last_line?(condition); end
end

class RuboCop::Cop::Style::TernaryParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_class(node); end
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_module(node); end
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def on_block(node); end
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  def on_def(node); end
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_masgn(node); end
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrivialAccessors
  include ::RuboCop::Cop::AllowedMethods
  def looks_like_trivial_writer?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::TrivialAccessors
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
end

class RuboCop::Cop::Style::UnlessElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnpackFirst
  def on_send(node); end

  def unpack_and_first_element?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::UnpackFirst
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
end

class RuboCop::Cop::Style::VariableInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhenThen
  def on_when(node); end
end

class RuboCop::Cop::Style::WhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilDo
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::WhileUntilDo
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::WhileUntilModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
end

class RuboCop::Cop::Style::WordArray
  extend ::RuboCop::Cop::AutoCorrector
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def file_constant_equal_program_name?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::YodaCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def non_polymorphic_collection?(node=T.unsafe(nil)); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
  LENGTH_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def required_minimum_ruby_version(); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def initialize(cops, config=T.unsafe(nil), options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def investigate(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
end

class RuboCop::Cop::Team
  def self.forces_for(cops); end

  def self.mobilize(cop_classes, config, options=T.unsafe(nil)); end

  def self.mobilize_cops(cop_classes, config, options=T.unsafe(nil)); end

  def self.new(cop_or_classes, config, options=T.unsafe(nil)); end
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, processed_source, node); end

  def self.correct_for_blockarg_type(corrector, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::TokensUtil
end

module RuboCop::Cop::Util
  def self.add_parentheses(node, corrector); end

  def self.args_begin(node); end

  def self.args_end(node); end

  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.comment_lines?(node); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.trim_string_interporation_escape_character(str); end
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end

  def valid?(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_if?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

module RuboCop::Cop::VisibilityHelp
  def visibility_block?(node=T.unsafe(nil)); end
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::Ext
end

module RuboCop::Ext::ProcessedSource
  def comment_config(); end

  def disabled_line_ranges(); end
end

module RuboCop::Ext::ProcessedSource
end

module RuboCop::Ext::RegexpNode
  def each_capture(named: T.unsafe(nil)); end

  def parsed_tree(); end
end

module RuboCop::Ext::RegexpNode
  def self.parsed_cache(); end
end

module RuboCop::Ext
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end

  def find_last_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end
end

module RuboCop::FileFinder
  def self.root_level=(level); end

  def self.root_level?(path, stop_dir); end
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::JUnitFormatter
  def classname_attribute_value(file); end

  def finished(_inspected_files); end

  def offenses_for_cop(all_offenses, cop); end

  def relevant_for_output?(options, target_offenses); end
end

class RuboCop::Formatter::JUnitFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::PacmanFormatter
  include ::RuboCop::Formatter::TextUtil
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  def started(_target_files); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_auto_correct: T.unsafe(nil)); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def valid_literal_value?(); end
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
end

module RuboCop::NameSimilarity
  def self.find_similar_name(target_name, names); end

  def self.find_similar_names(target_name, names); end
end

RuboCop::NodePattern = RuboCop::AST::NodePattern

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_redundant_disable?(); end

  def validate_auto_correct(); end

  def validate_auto_gen_config(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_display_only_failed(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.hidden_dir?(path); end

  def self.hidden_file?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.maybe_hidden_file?(path); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
end

class RuboCop::ResultCache
  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def save(offenses); end

  def valid?(); end
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def configured_include?(file); end

  def debug?(); end

  def excluded_dirs(base_dir); end

  def fail_fast?(); end

  def find(args, mode); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path, mode); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def toplevel_dirs(base_dir, flags); end
end

class RuboCop::TargetFinder
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::Source
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::TokensUtil
end

module RuboCop::TokensUtil
  def self.index_of_first_token(node); end

  def self.index_of_last_token(node); end

  def self.tokens(node); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  def self.version(debug: T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ArrayFilter
  def matches?(source_files_list); end
end

class SimpleCov::ArrayFilter
end

class SimpleCov::BlockFilter
  def matches?(source_file); end
end

class SimpleCov::BlockFilter
end

module SimpleCov::Combine
end

module SimpleCov::Combine::BranchesCombiner
end

module SimpleCov::Combine::BranchesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::FilesCombiner
end

module SimpleCov::Combine::FilesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::LinesCombiner
end

module SimpleCov::Combine::LinesCombiner
  def self.combine(coverage_a, coverage_b); end

  def self.merge_line_coverage(first_val, second_val); end
end

module SimpleCov::Combine::ResultsCombiner
end

module SimpleCov::Combine::ResultsCombiner
  def self.combine(*results); end

  def self.combine_file_coverage(coverage_a, coverage_b); end

  def self.combine_result_sets(combined_results, result); end
end

module SimpleCov::Combine
  def self.combine(combiner_module, coverage_a, coverage_b); end

  def self.empty_coverage?(coverage_a, coverage_b); end

  def self.existing_coverage(coverage_a, coverage_b); end
end

module SimpleCov::CommandGuesser
end

module SimpleCov::CommandGuesser
  def self.guess(); end

  def self.original_run_command(); end

  def self.original_run_command=(original_run_command); end
end

module SimpleCov::Configuration
  def adapters(); end

  def add_filter(filter_argument=T.unsafe(nil), &filter_proc); end

  def add_group(group_name, filter_argument=T.unsafe(nil), &filter_proc); end

  def at_exit(&block); end

  def at_fork(&block); end

  def branch_coverage?(); end

  def branch_coverage_supported?(); end

  def clear_coverage_criteria(); end

  def command_name(name=T.unsafe(nil)); end

  def configure(&block); end

  def coverage_criteria(); end

  def coverage_criterion(criterion=T.unsafe(nil)); end

  def coverage_criterion_enabled?(criterion); end

  def coverage_dir(dir=T.unsafe(nil)); end

  def coverage_path(); end

  def coverage_start_arguments_supported?(); end

  def enable_coverage(criterion); end

  def enable_for_subprocesses(value=T.unsafe(nil)); end

  def enabled_for_subprocesses?(); end

  def filters(); end

  def filters=(filters); end

  def formatter(formatter=T.unsafe(nil)); end

  def formatter=(formatter); end

  def formatters(); end

  def formatters=(formatters); end

  def groups(); end

  def groups=(groups); end

  def maximum_coverage_drop(coverage_drop=T.unsafe(nil)); end

  def merge_timeout(seconds=T.unsafe(nil)); end

  def minimum_coverage(coverage=T.unsafe(nil)); end

  def minimum_coverage_by_file(coverage=T.unsafe(nil)); end

  def nocov_token(nocov_token=T.unsafe(nil)); end

  def print_error_status(); end

  def print_error_status=(print_error_status); end

  def profiles(); end

  def project_name(new_name=T.unsafe(nil)); end

  def refuse_coverage_drop(); end

  def root(root=T.unsafe(nil)); end

  def skip_token(nocov_token=T.unsafe(nil)); end

  def track_files(glob); end

  def tracked_files(); end

  def use_merging(use=T.unsafe(nil)); end
  DEFAULT_COVERAGE_CRITERION = ::T.let(nil, ::T.untyped)
  SUPPORTED_COVERAGE_CRITERIA = ::T.let(nil, ::T.untyped)
end

module SimpleCov::Configuration
end

class SimpleCov::CoverageStatistics
  def covered(); end

  def initialize(covered:, missed:, total_strength: T.unsafe(nil)); end

  def missed(); end

  def percent(); end

  def strength(); end

  def total(); end
end

class SimpleCov::CoverageStatistics
  def self.from(coverage_statistics); end
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes::ExitCodeHandling
end

module SimpleCov::ExitCodes::ExitCodeHandling
  def self.call(result, coverage_limits:); end

  def self.coverage_checks(result, coverage_limits); end
end

class SimpleCov::ExitCodes::MaximumCoverageDropCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, maximum_coverage_drop); end

  def report(); end
end

class SimpleCov::ExitCodes::MaximumCoverageDropCheck
end

class SimpleCov::ExitCodes::MinimumCoverageByFileCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, minimum_coverage_by_file); end

  def report(); end
end

class SimpleCov::ExitCodes::MinimumCoverageByFileCheck
end

class SimpleCov::ExitCodes::MinimumOverallCoverageCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, minimum_coverage); end

  def report(); end
end

class SimpleCov::ExitCodes::MinimumOverallCoverageCheck
end

module SimpleCov::ExitCodes
end

class SimpleCov::FileList
  include ::Enumerable
  def branch_covered_percent(); end

  def count(*args, &block); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_percentages(); end

  def covered_strength(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(files); end

  def least_covered_file(); end

  def length(*args, &block); end

  def lines_of_code(); end

  def map(*args, &block); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def size(*args, &block); end

  def skipped_lines(); end

  def to_a(*args, &block); end

  def to_ary(*args, &block); end

  def total_branches(); end
end

class SimpleCov::FileList
  extend ::Forwardable
end

class SimpleCov::Filter
  def filter_argument(); end

  def initialize(filter_argument); end

  def matches?(_source_file); end

  def passes?(source_file); end
end

class SimpleCov::Filter
  def self.build_filter(filter_argument); end

  def self.class_for_argument(filter_argument); end
end

module SimpleCov::Formatter
end

class SimpleCov::Formatter::HTMLFormatter
  def branchable_result?(); end

  def format(result); end

  def line_status?(source_file, line); end

  def output_message(result); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::HTMLFormatter
end

class SimpleCov::Formatter::MultiFormatter
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
end

class SimpleCov::Formatter::MultiFormatter
  def self.[](*args); end

  def self.new(formatters=T.unsafe(nil)); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

class SimpleCov::Formatter::SimpleFormatter
end

module SimpleCov::Formatter
end

module SimpleCov::LastRun
end

module SimpleCov::LastRun
  def self.last_run_path(); end

  def self.read(); end

  def self.write(json); end
end

class SimpleCov::LinesClassifier
  def classify(lines); end
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  def self.no_cov_line(); end

  def self.no_cov_line?(line); end

  def self.whitespace_line?(line); end
end

class SimpleCov::Profiles
  def define(name, &blk); end

  def load(name); end
end

class SimpleCov::Profiles
end

class SimpleCov::RegexFilter
  def matches?(source_file); end
end

class SimpleCov::RegexFilter
end

class SimpleCov::Result
  def command_name(); end

  def command_name=(command_name); end

  def coverage_statistics(*args, &block); end

  def covered_branches(*args, &block); end

  def covered_lines(*args, &block); end

  def covered_percent(*args, &block); end

  def covered_percentages(*args, &block); end

  def covered_strength(*args, &block); end

  def created_at(); end

  def created_at=(created_at); end

  def filenames(); end

  def files(); end

  def format!(); end

  def groups(); end

  def initialize(original_result, command_name: T.unsafe(nil), created_at: T.unsafe(nil)); end

  def least_covered_file(*args, &block); end

  def missed_branches(*args, &block); end

  def missed_lines(*args, &block); end

  def original_result(); end

  def source_files(); end

  def time_since_creation(); end

  def to_hash(); end

  def total_branches(*args, &block); end

  def total_lines(*args, &block); end
end

class SimpleCov::Result
  extend ::Forwardable
  def self.from_hash(hash); end
end

class SimpleCov::ResultAdapter
  def adapt(); end

  def initialize(result); end

  def result(); end
end

class SimpleCov::ResultAdapter
  def self.call(*args); end
end

module SimpleCov::ResultMerger
end

module SimpleCov::ResultMerger
  def self.clear_resultset(); end

  def self.merge_and_store(*results); end

  def self.merge_results(*results); end

  def self.merged_result(); end

  def self.results(); end

  def self.resultset(); end

  def self.resultset_path(); end

  def self.resultset_writelock(); end

  def self.store_result(result); end

  def self.stored_data(); end

  def self.synchronize_resultset(); end
end

module SimpleCov::SimulateCoverage
end

module SimpleCov::SimulateCoverage
  def self.call(absolute_path); end
end

class SimpleCov::SourceFile
  def branches(); end

  def branches_coverage_percent(); end

  def branches_for_line(line_number); end

  def branches_report(); end

  def coverage_data(); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_strength(); end

  def filename(); end

  def initialize(filename, coverage_data); end

  def line(number); end

  def line_with_missed_branch?(line_number); end

  def lines(); end

  def lines_of_code(); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def no_branches?(); end

  def no_lines?(); end

  def project_filename(); end

  def relevant_lines(); end

  def skipped_lines(); end

  def source(); end

  def source_lines(); end

  def src(); end

  def total_branches(); end
  RUBY_FILE_ENCODING_MAGIC_COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SHEBANG_REGEX = ::T.let(nil, ::T.untyped)
end

class SimpleCov::SourceFile::Branch
  def coverage(); end

  def covered?(); end

  def end_line(); end

  def initialize(start_line:, end_line:, coverage:, inline:, type:); end

  def inline?(); end

  def missed?(); end

  def overlaps_with?(line_range); end

  def report(); end

  def report_line(); end

  def skipped!(); end

  def skipped?(); end

  def start_line(); end

  def type(); end
end

class SimpleCov::SourceFile::Branch
end

class SimpleCov::SourceFile::Line
  def coverage(); end

  def covered?(); end

  def initialize(src, line_number, coverage); end

  def line(); end

  def line_number(); end

  def missed?(); end

  def never?(); end

  def number(); end

  def skipped(); end

  def skipped!(); end

  def skipped?(); end

  def source(); end

  def src(); end

  def status(); end
end

class SimpleCov::SourceFile::Line
end

class SimpleCov::SourceFile
end

class SimpleCov::StringFilter
  def matches?(source_file); end
end

class SimpleCov::StringFilter
end

module SimpleCov::UselessResultsRemover
end

module SimpleCov::UselessResultsRemover
  def self.call(coverage_result); end

  def self.root_regx(); end
end

module SimpleCov
  extend ::SimpleCov::Configuration
  def self.at_exit_behavior(); end

  def self.clear_result(); end

  def self.collate(result_filenames, profile=T.unsafe(nil), &block); end

  def self.exit_and_report_previous_error(exit_status); end

  def self.exit_status_from_exception(); end

  def self.external_at_exit(); end

  def self.external_at_exit=(external_at_exit); end

  def self.external_at_exit?(); end

  def self.filtered(files); end

  def self.final_result_process?(); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.previous_error?(error_exit_status); end

  def self.process_result(result); end

  def self.process_results_and_report_error(); end

  def self.ready_to_process_results?(); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result); end

  def self.round_coverage(coverage); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.wait_for_other_processes(); end

  def self.write_last_run(result); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def blank?(); end

  def ext(newext=T.unsafe(nil)); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def shellescape(); end

  def shellsplit(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringScanner
  def bol?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thor
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Thor::Actions::CapturableERB
end

class Thor::Actions::CapturableERB
end

module Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Thor::Actions::ClassMethods
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::CreateLink
end

class Thor::Actions::CreateLink
end

class Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Thor::Actions::Directory
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

class Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Thor::Actions::InjectIntoFile
end

module Thor::Actions
  def self.included(base); end
end

class Thor::AmbiguousCommandError
end

class Thor::AmbiguousCommandError
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Argument
end

class Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Thor::Command
end

module Thor::CoreExt
end

class Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Thor::CoreExt::HashWithIndifferentAccess
end

module Thor::CoreExt
end

Thor::Correctable = DidYouMean::Correctable

class Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Thor::DynamicCommand
end

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Error
end

class Thor::Error
end

class Thor::Group
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Thor::HiddenCommand
end

class Thor::HiddenCommand
end

Thor::HiddenTask = Thor::HiddenCommand

module Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Thor::Invocation
  def self.included(base); end
end

class Thor::InvocationError
end

class Thor::InvocationError
end

module Thor::LineEditor
end

class Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Thor::LineEditor::Basic
  def self.available?(); end
end

class Thor::LineEditor::Readline
end

class Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Thor::LineEditor::Readline::PathCompletion
end

class Thor::LineEditor::Readline
end

module Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Thor::MalformattedArgumentError
end

class Thor::MalformattedArgumentError
end

class Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Thor::NestedContext
end

class Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Thor::NoKwargSpellChecker
end

class Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Option
  def self.parse(key, value); end
end

class Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  def self.to_switches(options); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Thor::RequiredArgumentMissingError
end

class Thor::RequiredArgumentMissingError
end

module Thor::Sandbox
end

module Thor::Sandbox
end

module Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Thor::Shell
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UndefinedCommandError::SpellChecker
end

class Thor::UndefinedCommandError
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UnknownArgumentError::SpellChecker
end

class Thor::UnknownArgumentError
end

module Thor::Util
end

module Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Thor
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
